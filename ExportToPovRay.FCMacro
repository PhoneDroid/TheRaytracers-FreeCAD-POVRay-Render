# -*- coding: utf-8 -*-

#  Export FreeCAD models to POV-Ray
#  Copyright (C) 2019  Usb Hub and DerUhrmacher
#
#  This library is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public
#  License as published by the Free Software Foundation; either
#  version 2.1 of the License, or (at your option) any later version.
#
#  This library is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with this library; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

from FreeCAD import Base
from pivy import coin
import os
from PySide import QtCore, QtGui
import math
import MeshPart
import platform
import subprocess
import xml.etree.ElementTree as xml
import csv
import hashlib
import tempfile

macroVersion = "0.1 beta"

def showError(text, title): #show an error box
    dialog = QtGui.QMessageBox(QtGui.QMessageBox.Critical, title, text)
    dialog.setWindowModality(QtCore.Qt.ApplicationModal)
    dialog.exec_()

def isAscii(string): #test whether the string is an ASCII string
    return all(ord(c) < 128 for c in string)

def stringCorrection(inputString): # String correction for compatibility with POV-Ray 
        utfString = inputString.encode("utf8", "replace")     # conversion from ??? to utf8
        uniString = utfString.decode("utf8", "replace")       # conversion from utf8 to unicode
        firstchar = ord(uniString[0])                         # POV-Ray doesn't like numbers as first charakter
        if firstchar >= 48 and firstchar <= 57:
            uniString = "_" + uniString
        uniString = uniString.replace(u"Ä", "Ae")             # replacement of german "Umlaute"
        uniString = uniString.replace(u"ä", "ae")
        uniString = uniString.replace(u"Ü", "Ue")
        uniString = uniString.replace(u"ü", "ue")
        uniString = uniString.replace(u"Ö", "Oe")
        uniString = uniString.replace(u"ö", "oe")
        uniString = uniString.replace(u"ß", "ss")
        uniString = uniString.replace(u"(", "_")
        uniString = uniString.replace(u")", "_")
        uniString = uniString.replace(u"#", "_")
        uniString = uniString.replace(u".", "_")
        uniString = uniString.replace(u",", "_")
        uniString = uniString.replace(u"-", "_")
        uniString = uniString.replace(u"+", "_")
        uniString = uniString.replace(u"*", "_")
        uniString = uniString.replace(u"/", "_")
        uniString = uniString.replace(" ", "_")
        outString = uniString.encode("ASCII", "replace")      # conversion to ASCII for POV-Ray compatibility
        return outString.decode("utf-8")                      #return and redecode to unicode but with converted chars

def strToBool(str):
    if str == True:
        return True
    elif str == False:
        return False

    return str.lower() in ['true', '1', 'y']


class ExportToPovRay:
    """Export the FreeCAD model to POV-Ray"""
    def __init__(self, renderSettings):
        self.doc = FreeCAD.ActiveDocument
        self.objs = self.doc.Objects

        #get all paths, file names, directories, etc.
        self.projectName = renderSettings.projectName
        self.directory = renderSettings.directory

        self.iniName = renderSettings.iniName
        self.iniPath = renderSettings.iniPath
        self.povName = renderSettings.povName
        self.povPath = renderSettings.povPath
        
        self.incName = renderSettings.incName
        self.incPath = renderSettings.incPath
        self.meshName = renderSettings.meshName
        self.meshPath = renderSettings.meshPath
        self.errorName = renderSettings.errorName
        self.errorPath = renderSettings.errorPath
        self.fcViewName = renderSettings.fcViewName
        self.fcViewPath = renderSettings.fcViewPath
        self.texIncName = renderSettings.texIncName
        self.texIncPath = renderSettings.texIncPath

        self.meshFileContent = ""

        #get all output options
        self.width = renderSettings.width
        self.height = renderSettings.height

        self.expBg = renderSettings.expBg
        self.expLight = renderSettings.expLight
        self.repRot = renderSettings.repRot
        self.expFcView = renderSettings.expFcView

        #get default shape color (editable in FreeCAD settings) (default rgb(0.8, 0.8, 0.8))
        self.DefaultShapeColor =  App.ParamGet("User parameter:BaseApp/Preferences/View").GetUnsigned('DefaultShapeColor')

        #get camera
        self.CamOri = Gui.ActiveDocument.ActiveView.getCameraOrientation()
        self.CamType = Gui.ActiveDocument.ActiveView.getCameraType()
        self.CamPos = Gui.ActiveDocument.ActiveView.viewPosition()
        self.CamNode = Gui.ActiveDocument.ActiveView.getCameraNode()
        self.EulerCam = Gui.ActiveDocument.ActiveView.getCameraOrientation().toEuler()

        self.os = platform.system() #get system informations

        #exist a user inc file
        self.userInc = False

        if self.povPath != -1 and self.povPath != "" and self.povPath != " ": #is there a pov file
            try: #try to open pov file
                file = open(self.povPath, "w+") #XXX really "w+"?
                file.close()
            except:
                App.Console.PrintError("Can't open the pov file\n\n")
                return -1

            try: #try to open inc file
                file = open(self.incPath, "r")
                self.incContent = file.read()
                file.close()

                App.Console.PrintMessage("Include file found: " + self.incPath + "\n")
                self.incContent = self.delComments(self.incContent)
                self.userInc = True
            except:
                self.incContent = ""

            #open texture inc file
            file = open(self.texIncPath, "r")
            self.texIncContent = file.read()
            file.close()
        else:
            App.Console.PrintMessage("\n\nCanceled\n\n")
            return -1

        #get statistics
        objs = FreeCAD.ActiveDocument.Objects
        self.statistics = self.getStatistics(objs)
        App.Console.PrintMessage(self.statistics)

        #clear old mesh file
        try:
            file = open(self.meshPath, "w")
            file.close()
        except:
            pass


        self.startExport() #start the export

    def startExport(self): #start the export to POV-Ray
        firstLayer = [] #the highest objects in the model tree

        #repair rotation (see documentation)
        if self.repRot:
            self.repairRotation(self.objs)

        #export FreeCAD view
        if self.expFcView:
            self.exportFcView()

        #get the first layer and check visibility of parent objects
        for obj in self.objs:
            guiObject = obj.ViewObject
            if guiObject.Visibility and obj.TypeId != "App::DocumentObjectGroup" and not self.hasBodyAsParent(obj) and not self.hasPartAsParent(obj):
                firstLayer.append(obj)

        #create pov code of objects
        objPovCode = ""
        for obj in firstLayer:
            objPovCode += self.createPovCode(obj, True, True, True, True, True)

        #add general pov code / "header"
        finalPovCode = "#version 3.6; // 3.7\nglobal_settings { assumed_gamma 1.0 }\n#default { finish { ambient 0.2 diffuse 0.9 } }\n"

        finalPovCode += "#default { pigment { rgb " + self.uintColorToRGB(self.DefaultShapeColor) + " } }\n"

        finalPovCode += "\n//------------------------------------------\n"
        finalPovCode += "#include \"colors.inc\"\n#include \"textures.inc\"\n"

        #add textures inc include
        finalPovCode += "#include \"" + self.texIncName + "\"\n"

        #if model contains mesh objects, a mesh file will be included
        if self.meshFileContent != "":
            finalPovCode += "#include \"" + self.meshName + "\"\n"

        finalPovCode += "\n//------------------------------------------\n"
        finalPovCode += "// camera ----------------------------------\n"
        finalPovCode += self.getCam()

        if self.expLight:
            finalPovCode += "\n// sun -------------------------------------\n"
            finalPovCode += self.getLight()

        if self.expBg:
            finalPovCode += "\n// background ------------------------------\n"
            finalPovCode += self.getBackground()

        finalPovCode += "\n//------------------------------------------\n"

        if self.userInc: #include user inc file if there is a file
            finalPovCode += "\n#include \"" + self.incName + "\"\n\n"

        finalPovCode += "// objects in scene ------------------------\n"

        finalPovCode += objPovCode

        #change line breaks for windows
        if self.os == "Windows":
            finalPovCode.replace("\n", "\r\n")
            self.meshFileContent.replace("\n", "\r\n")

        #write mesh file
        if self.meshFileContent != "":
            self.meshFile = open(self.meshPath, "w")
            self.meshFile.write(self.meshFileContent)
            self.meshFile.close()

        self.writeFile(finalPovCode) #write the final code to the output file
        self.openPovRay() #start povray


    def createPovCode(self, fcObj, expPlacement, expPigment, expClose, expLabel, expMeshDef): #returns the povray code for the object
        if expLabel:
            povCode = "\n//----- " + stringCorrection(fcObj.Label) + " -----" #add the name of the object
        else:
            povCode = ""

        if fcObj.TypeId == "Part::Box": #Box
            povBox = "\nbox { <0,0,0>, <" + str(float(fcObj.Length)) + ", " + str(float(fcObj.Width)) + ", " + str(float(fcObj.Height)) + ">"
            povCode += povBox

        elif fcObj.TypeId == "Part::Sphere": # Sphere
            radius = fcObj.Radius.getValueAs("mm")

            povSphere = "\nsphere { <0, 0, 0> " + str(radius)

            povCode += povSphere

        elif fcObj.TypeId == "Part::Ellipsoid": # Ellipsoid
            r1 = fcObj.Radius1.getValueAs("mm").Value
            r2 = fcObj.Radius2.getValueAs("mm").Value
            r3 = fcObj.Radius3.getValueAs("mm").Value

            povSphere = "\nsphere { <0, 0, 0> 1\n"

            povSphere += "\tscale <" + str(r2) + ", " + str(r3) + ", " + str(r1) + ">"

            povCode += povSphere

        elif fcObj.TypeId == "Part::Cone": #Cone
            r1 = fcObj.Radius1.getValueAs("mm").Value
            c1 = "<0, 0, 0>"
            r2 = fcObj.Radius2.getValueAs("mm").Value
            c2 = "<0, 0, " + str(fcObj.Height.getValueAs("mm").Value) + ">"

            povCone = "\ncone { "
            povCone += c1 + ", " + str(r1) + "\n    "
            povCone += c2 + ", " + str(r2)

            povCode += povCone

        elif fcObj.TypeId == "Part::Cylinder": #Cylinder
            r = fcObj.Radius.getValueAs("mm").Value
            baseP = "<0, 0, 0>"
            CapP = "<0, 0, " + str(fcObj.Height.getValueAs("mm").Value) + ">"

            povCylinder = "\ncylinder { "
            povCylinder += baseP + ", " + CapP + ", " + str(r)

            povCode += povCylinder

        elif fcObj.TypeId == "Part::Torus": #Torus
            r1 = fcObj.Radius1.getValueAs("mm").Value
            r2 = fcObj.Radius2.getValueAs("mm").Value

            povTorus = "\ntorus { "
            povTorus += str(r1) + ", " + str(r2)

            povCode += povTorus

        elif fcObj.TypeId == "Part::Plane": #Plane
            width = fcObj.Width.getValueAs("mm").Value
            length = fcObj.Length.getValueAs("mm").Value

            povPlane = "\npolygon { "
            povPlane += "5, <0, 0>, <" + str(length) + ", 0>, <" + str(length) + ", " + str(width) + ">, <0, " + str(width) + ">, <0, 0>"

            povCode += povPlane

        elif fcObj.TypeId == "Part::Cut":  #Cut
            childs = fcObj.OutList
            povCut = "\ndifference {\n"
            for child in childs:
                childCode = self.createPovCode(child, True, expPigment, True, expLabel, expMeshDef) #call createPovCode for the child
                povCut += childCode.replace("\n", "\n\t") #add the indents

            povCode += povCut

        elif fcObj.TypeId == "Part::MultiFuse" or fcObj.TypeId == "Part::Fuse" or fcObj.TypeId == "Part::Compound": #Fusion
            childs = fcObj.OutList
            povFusion = "\nunion {\n"
            for child in childs:
                childCode = self.createPovCode(child, True, expPigment, True, expLabel, expMeshDef) #call createPovCode for the child
                povFusion += childCode.replace("\n", "\n\t") #add the indents

            povCode += povFusion

        elif fcObj.TypeId == "Part::MultiCommon" or fcObj.TypeId == "Part::Common": #Common
            childs = fcObj.OutList
            povCommon = "\nintersection {\n"
            for child in childs:
                childCode = self.createPovCode(child, True, expPigment, True, expLabel, expMeshDef) #call createPovCode for the child
                povCommon += childCode.replace("\n", "\n\t") #add the indents

            povCode += povCommon

        elif fcObj.TypeId == "Part::FeaturePython" and fcObj.Name.startswith("Array"): #Array from Draft workbench
            povArr = ""
            if fcObj.ArrayType == "polar":
                child = fcObj.Base
                #for child in childs:
                center = "<" + str(fcObj.Center.x) + ", " + str(fcObj.Center.y) + ", " + str(fcObj.Center.z) + ">"
                axisX = fcObj.Axis.x
                axisY = fcObj.Axis.y
                axisZ = fcObj.Axis.z
                highestAxis = max(axisX, axisY, axisZ) #get highest value
                axisX /= highestAxis
                axisY /= highestAxis
                axisZ /= highestAxis


                axis = "<" + str(axisX) + ", " + str(axisY) + ", " + str(axisZ) + ">"
                intervalAxis = "<" + str(fcObj.IntervalAxis.x) + ", " + str(fcObj.IntervalAxis.y) + ", " + str(fcObj.IntervalAxis.z) + ">"
                number = fcObj.NumberPolar
                angle = fcObj.Angle.getValueAs("deg").Value

                declareName = stringCorrection(child.Label.capitalize()) + "_" + child.Name
                povArr += "\n#declare " + declareName + " = "
                childCode = self.createPovCode(child, True, expPigment, True, expLabel, expMeshDef) #call createPovCode for the child
                povArr += childCode

                povArr += "\n#declare i = 0;\n"
                povArr += "#declare endNo = " + str(number) + ";\n"
                povArr += "#declare axis = " + axis + ";\n"
                povArr += "#declare arrAngle = " + str(angle) + ";\n"
                povArr += "#while (i < endNo)\n"
                povArr += "\tobject { " + declareName + "\n"
                if fcObj.Center.x != 0 or fcObj.Center.y != 0 or fcObj.Center.z != 0:
                    povArr += "\t\ttranslate -" + center + "\n"

                povArr += "\t\t#declare rotAngle = i * arrAngle / (endNo-1);\n"
                povArr += "\t\t#local vX = vaxis_rotate(x, axis, rotAngle);\n"
                povArr += "\t\t#local vY = vaxis_rotate(y, axis, rotAngle);\n"
                povArr += "\t\t#local vZ = vaxis_rotate(z, axis, rotAngle);\n"
                povArr += "\t\ttransform {\n"
                povArr += "\t\t\tmatrix <vX.x, vX.y, vX.z, vY.x, vY.y, vY.z, vZ.x, vZ.y, vZ.z, 0, 0, 0>\n"
                povArr += "\t\t}\n"

                if fcObj.Center.x != 0 or fcObj.Center.y != 0 or fcObj.Center.z != 0:
                    povArr += "\t\ttranslate " + center + "\n"

                if expPlacement:
                    rotation = self.getRotation(fcObj)
                    if rotation != "": #test if the object is rotated
                        povArr += "        " + rotation + "\n"

                if fcObj.IntervalAxis.x != 0 or fcObj.IntervalAxis.y != 0 or fcObj.IntervalAxis.z != 0:
                    povArr += "\t\ttranslate " + intervalAxis + " * i\n"

                if expPlacement:
                    translation = self.getTranslation(fcObj)
                    if translation != "": #test if the object is translated
                        povArr += "\t" + translation + "\n"

                if expPigment:
                    pigment = self.getPigment(fcObj)
                    if pigment != "": #test if the object has the standard pigment
                        povArr += "\t" + pigment + "\n"

                povArr += "    }\n\t#declare i = i + 1;\n"
                povArr += "#end\n"

            elif fcObj.ArrayType == "ortho":
                child = fcObj.Base
                #for child in childs:
                intervalX = "<" + str(fcObj.IntervalX.x) + ", " + str(fcObj.IntervalX.y) + ", " + str(fcObj.IntervalX.z) + ">"
                intervalY = "<" + str(fcObj.IntervalY.x) + ", " + str(fcObj.IntervalY.y) + ", " + str(fcObj.IntervalY.z) + ">"
                intervalZ = "<" + str(fcObj.IntervalZ.x) + ", " + str(fcObj.IntervalZ.y) + ", " + str(fcObj.IntervalZ.z) + ">"

                numX = fcObj.NumberX
                if numX == 0:
                    numX = 1

                numY = fcObj.NumberY
                if numY == 0:
                    numY = 1

                numZ = fcObj.NumberZ
                if numZ == 0:
                    numZ = 1

                declareName = stringCorrection(child.Label.capitalize()) + "_" + child.Name
                povArr += "\n#declare " + declareName + " = "
                childCode = self.createPovCode(child, True, expPigment, True, expLabel, True) #call createPovCode for the child
                povArr += childCode

                povArr += "#declare intervalX = " + intervalX + ";\n"
                povArr += "#declare intervalY = " + intervalY + ";\n"
                povArr += "#declare intervalZ = " + intervalZ + ";\n\n"

                povArr += "#declare numX = " + str(numX) + ";\n"
                povArr += "#declare ix = 0;\n"
                povArr += "#while (ix < numX)\n"

                povArr += "\t#declare numY = " + str(numY) + ";\n"
                povArr += "\t#declare iy = 0;\n"
                povArr += "\t#while (iy < numY)\n"

                povArr += "\t\t#declare numZ = " + str(numZ) + ";\n"
                povArr += "\t\t#declare iz = 0;\n"
                povArr += "\t\t#while (iz < numZ)\n"

                povArr += "\t\t\tobject { " + declareName + "\n"
                povArr += "\t\t\t\ttranslate intervalX * ix\n"
                povArr += "\t\t\t\ttranslate intervalY * iy\n"
                povArr += "\t\t\t\ttranslate intervalZ * iz\n"

                if expPlacement:
                    translation = self.getTranslation(fcObj)
                    if translation != "": #test if the object is translated
                        povArr += "\t\t\t\t" + translation + "\n"

                    rotation = self.getRotation(fcObj)
                    if rotation != "": #test if the object is rotated
                        povArr += "\t\t\t\t" + rotation + "\n"

                if expPigment:
                    pigment = self.getPigment(fcObj)
                    if pigment != "": #test if the object has the standard pigment
                        povArr += "\t\t\t\t" + pigment + "\n"

                povArr += "\t\t\t}\n"

                povArr += "\t\t\t#declare iz = iz + 1;\n"
                povArr += "\t\t#end\n"
                povArr += "\t\t#declare iy = iy + 1;\n"
                povArr += "\t#end\n"
                povArr += "\t#declare ix = ix + 1;\n"
                povArr += "#end\n"

            else:
                povCode += self.createMesh(fcObj, expPlacement, expPigment, expClose, expMeshDef)

            povArr = povArr.replace("\n", "\n\t")
            povCode += "\nunion {\n"
            povCode += povArr
            expPigment = False
            expPlacement = False

        elif fcObj.TypeId == "Part::FeaturePython" and fcObj.Name.startswith("Clone"): #Clone from Draft workbench
            povClone = ""

            childs = fcObj.Objects
            for child in childs:
                povClone += self.createPovCode(child, False, False, False, False, True)

            if fcObj.Scale.x != 1 or fcObj.Scale.y != 1 or fcObj.Scale.z != 1:
                povClone += "\n\tscale <" + str(fcObj.Scale.x) + ", " + str(fcObj.Scale.y) + ", " + str(fcObj.Scale.z) + ">"

            povCode += povClone

        elif fcObj.TypeId == "Part::Extrusion":
            if not self.isExtrudeSupported(fcObj):
                povCode += self.createMesh(fcObj, expPlacement, expPigment, expClose, expMeshDef)
                return povCode #return because the mesh may not translated and rotated

            spline = self.sketchToBezier(fcObj.Base)

            startHeight = 0
            endHeight = fcObj.LengthFwd.getValueAs("mm").Value

            if fcObj.Symmetric:
                endHeight /= 2
                startHeight = -endHeight

            startHeight -= fcObj.LengthRev.getValueAs("mm").Value

            if not fcObj.Reversed:
                startHeight *= -1
                endHeight *= -1

            povPad = ""
            povPad += "\nprism {\n"
            povPad += "\tbezier_spline\n"
            povPad += "\t" + str(startHeight) + ", " + str(endHeight) + ", " + str(spline[1])
            povPad += spline[0].replace("\n", "\n\t") + "\n" #add the indents

            if expPlacement:
                rotation = self.getRotation(fcObj.Base)
                if rotation != "": #test if the object is rotated
                    povPad += "\t" + rotation + "\n"

                translation = self.getTranslation(fcObj.Base)
                if translation != "": #test if the object is translated
                    povPad += "\t" + translation + "\n"

            povCode += povPad

        elif fcObj.TypeId == "Image::ImagePlane":
            image = fcObj.ImageFile
            imgType = image[-3:]

            width = fcObj.XSize.getValueAs("mm").Value
            height = fcObj.YSize.getValueAs("mm").Value

            povImg = "\npolygon { "
            povImg += "5, <0, 0>, <" + str(width) + ", 0>, <" + str(width) + ", " + str(height) + ">, <0, " + str(height) + ">, <0, 0>"

            povPigment = "\npigment {\n"
            povPigment += "\timage_map {\n"
            povPigment += "\t\t" + imgType + ' "' + image + '"\n'
            povPigment += "\t\tmap_type 0\n"
            povPigment += "\t}\n"
            povPigment += "\tscale <" + str(width) + ", " + str(height) + ", 1>\n"
            povPigment += "}\n"

            povImg += povPigment.replace("\n", "\n\t")
            povImg += "\ttranslate -<" + str(width / 2) + ", " + str(height / 2) + ", 0>\n"

            expPigment = False
            povCode += povImg

        elif fcObj.TypeId == "App::Part": #Part
            povPart = "\nunion {\n"

            childs = fcObj.OutList
            for child in childs:
                guiChild = child.ViewObject
                if guiChild.Visibility:
                    childCode = self.createPovCode(child, True, expPigment, True, expLabel, expMeshDef) #call createPovCode for the child
                    povPart += childCode.replace("\n", "\n\t") #add the indents

            povCode += povPart
            expPigment = False #part has no pigment


        elif fcObj.TypeId == "PartDesign::Body": #Body from PartDesign
            if not self.isBodySupported(fcObj):
                povCode += self.createMesh(fcObj, expPlacement, expPigment, expClose, expMeshDef)
                return povCode #return because the mesh may not translated and rotated

            povBody = "\nunion {\n"
            if fcObj.Tip != None:
                povBody += self.createPovCode(fcObj.Tip, True, True, True, True, True).replace("\n", "\n\t") #add chld code and indents
                povCode += povBody
            else:
                return ""

        elif fcObj.TypeId == "PartDesign::Pad" or fcObj.TypeId == "PartDesign::Pocket": #Pad or Pocket from PartDesign
            povPad = ""
            spline = self.sketchToBezier(fcObj.Profile[0])

            if (self.isSketchSupported(fcObj.Profile[0]) == False) or spline == -1 or (self.isPadPocketSupported(fcObj) == False):
                povPad += self.createMesh(fcObj, expPlacement, True, expClose, expMeshDef)
                povCode += povPad
                return povCode

            startHeight = 0
            if fcObj.TypeId == "PartDesign::Pocket":
                startHeight = -0.0001
            endHeight = fcObj.Length.getValueAs("mm").Value
            if fcObj.Midplane:
                endHeight /= 2
                startHeight = -endHeight
            if not fcObj.Reversed:
                startHeight *= -1
                endHeight *= -1
            if fcObj.TypeId == "PartDesign::Pocket":
                startHeight *= -1
                endHeight *= -1

            try:
                if fcObj.TypeId == "PartDesign::Pocket":
                    povPad += "\ndifference {\n"
                else:
                    povPad += "\nunion {\n"
            except:
                povPad += "\nunion {\n"

            if fcObj.BaseFeature != None:
                povBase = self.createPovCode(fcObj.BaseFeature, True, True, True, True, True)
                povPad += povBase.replace("\n", "\n\t") #add the indents

            povPad += "\n\tprism {\n"
            povPad += "\t\tbezier_spline\n"
            povPad += "\t\t" + str(startHeight) + ", " + str(endHeight) + ", " + str(spline[1])
            povPad += spline[0].replace("\n", "\n\t\t") + "\n" #add the indents

            if expPlacement:
                rotation = self.getRotation(fcObj.Profile[0])
                if rotation != "": #test if the object is rotated
                    povPad += "\t\t" + rotation + "\n"

                translation = self.getTranslation(fcObj.Profile[0])
                if translation != "": #test if the object is translated
                    povPad += "\t\t" + translation + "\n"
            else:
                rotation = "\t\trotate <-90, 0, 0>"
                povPad += rotation

            povPad += "\n\t}\n"

            if expClose:
                povPad += "\n}\n"

            povCode += povPad
            return povCode

        else: #not a supported object
            povCode += self.createMesh(fcObj, expPlacement, expPigment, expClose, expMeshDef)
            return povCode #return because the mesh may not translated and rotated

        povCode += "\n"

        if expPlacement:
            rotation = self.getRotation(fcObj)
            if rotation != "": #test if the object is rotated
                povCode += "\t" + rotation + "\n"

            translation = self.getTranslation(fcObj)
            if translation != "": #test if the object is translated
                povCode += "\t" + translation + "\n"

        if expPigment:
            pigment = self.getPigment(fcObj)
            if pigment != "": #test if the object has the standard pigment
                povCode += pigment.replace("\n", "\n\t") + "\n"

        if expClose:
            povCode += "}\n"

        return povCode


    def sketchToBezier(self, sketch): #create pov bezier_spline from sketch
        try:
            povSpline = "\n"

            unsortedLines = sketch.Geometry #unordered lines / original order

            #delete construction geometry and points
            unsortedLines = [line for line in unsortedLines if not (line.Construction or type(line) == Part.Point)]

            numOfPoints = 0

            sortedLines = [] #lines in the right order

            while unsortedLines: #until the unsortedLines array is empty
                sortedLines.append(unsortedLines[0])
                startLine = unsortedLines[0]
                del unsortedLines[0]

                if type(startLine) != Part.Circle and type(sortedLines[len(sortedLines) - 1]) != Part.Circle:
                    while not self.isSamePoint(startLine.StartPoint, sortedLines[len(sortedLines) - 1].EndPoint):
                        # handling of -1 missing
                        nextLineI = self.getNextLine(unsortedLines, sortedLines[len(sortedLines) - 1])

                        #change direction
                        if self.isSamePoint(sortedLines[len(sortedLines) - 1].EndPoint, unsortedLines[nextLineI].EndPoint):
                            unsortedLines[nextLineI].reverse()

                        sortedLines.append(unsortedLines[nextLineI])
                        del unsortedLines[nextLineI]

        except:
            return -1

        #create povSpline
        for line in sortedLines:
            if type(line) == Part.LineSegment:
                povSpline += "<" + str(line.StartPoint.x) + ", " + str(line.StartPoint.y) + ">, "
                povSpline += "<" + str(line.StartPoint.x) + ", " + str(line.StartPoint.y) + ">, "
                povSpline += "<" + str(line.EndPoint.x) + ", " + str(line.EndPoint.y) + ">, "
                povSpline += "<" + str(line.EndPoint.x) + ", " + str(line.EndPoint.y) + ">\n"

                numOfPoints += 4

            elif type(line) == Part.Circle:
                r = line.Radius
                cx = line.Center.x
                cy = line.Center.y
                dTC = (4.0/3.0) * math.tan(math.pi / 8.0) * r #distance to control point

                posP0 = "<" + str(cx) + ", " + str(cy + r) + ">"
                controlP0_0 = "<" + str(cx - dTC) + ", " + str(cy + r) + ">"
                controlP0_1 = "<" + str(cx + dTC) + ", " + str(cy + r) + ">"

                posP1 = "<" + str(cx + r) + ", " + str(cy) + ">"
                controlP1_0 = "<" + str(cx + r) + ", " + str(cy + dTC) + ">"
                controlP1_1 = "<" + str(cx + r) + ", " + str(cy - dTC) + ">"

                posP2 = "<" + str(cx) + ", " + str(cy - r) + ">"
                controlP2_0 = "<" + str(cx + dTC) + ", " + str(cy - r) + ">"
                controlP2_1 = "<" + str(cx - dTC) + ", " + str(cy - r) + ">"

                posP3 = "<" + str(cx - r) + ", " + str(cy) + ">"
                controlP3_0 = "<" + str(cx - r) + ", " + str(cy - dTC) + ">"
                controlP3_1 = "<" + str(cx - r) + ", " + str(cy + dTC) + ">"

                povSpline += posP0 + ", " + controlP0_1 + ", " + controlP1_0 + ", " + posP1 + "\n"
                povSpline += posP1 + ", " + controlP1_1 + ", " + controlP2_0 + ", " + posP2 + "\n"
                povSpline += posP2 + ", " + controlP2_1 + ", " + controlP3_0 + ", " + posP3 + "\n"
                povSpline += posP3 + ", " + controlP3_1 + ", " + controlP0_0 + ", " + posP0 + "\n"

                numOfPoints += 16

        return [povSpline, numOfPoints]

    def getNextLine(self, lines, lastLine): #get index of next line for the given last line
        #returns index
        i = 0
        for line in lines:
            if self.isSamePoint(line.EndPoint, lastLine.EndPoint) or self.isSamePoint(line.StartPoint, lastLine.EndPoint):
                return i
            i += 1
        return -1

    def isSamePoint(self, point1, point2): #are two points equal
        #round because FreeCAD has rounding mistakes
        if round(point1.x, 3) == round(point2.x, 3) and round(point1.y, 3) == round(point2.y, 3) and round(point1.z, 3) == round(point2.z, 3):
            return True
        return False

    def hasLinesConstructive(self, lines): #are constructive lines in lines array
        constructive = False
        for line in lines:
            if line.Construction:
                return True
        return False

    def isBodySupported(self, body): #is a body full supported
        supportedTypeIds = ["App::Origin",
                            "App::Line",
                            "App::Plane",
                            "Sketcher::SketchObject",
                            "PartDesign::Pad",
                            "PartDesign::Pocket",
                            "PartDesign::Point",
                            "PartDesign::Line",
                            "PartDesign::Plane"]

        childs = body.OutListRecursive

        #are objects supported
        for obj in childs:
            if not obj.TypeId in supportedTypeIds:
                return False

        #get sketches
        sketches = []
        for obj in childs:
            if obj.TypeId == "Sketcher::SketchObject":
                sketches.append(obj)

        #test sketches
        for sketch in sketches:
            if not self.isSketchSupported(sketch):
                return False

        supportedTypes = ["Length"]
        #get pads and pockets
        padsPockets = []
        for obj in childs:
            if obj.TypeId == "PartDesign::Pad" or obj.TypeId == "PartDesign::Pocket":
                padsPockets.append(obj)

        #test types
        for obj in padsPockets:
            if not obj.Type in supportedTypes:
                return False

        return True

    def isPadPocketSupported(self, fcObj):
        supportedTypes = ["Length"]

        if not (obj.TypeId == "PartDesign::Pad" or obj.TypeId == "PartDesign::Pocket"):
            return False

        if not fcObj.Type in supportedTypes:
            return False

        if not self.isSketchSupported(fcObj.Profile[0]):
            return False

        return True

    def isExtrudeSupported(self, fcObj):
        #test mode of direction
        if fcObj.DirMode != "Normal":
            return False

        #test TaperAngle and TaperAngleRev
        if fcObj.TaperAngle.getValueAs("deg").Value != 0 or fcObj.TaperAngleRev.getValueAs("deg").Value:
            return False
        
        #test base shape (only sketches are supported)
        if fcObj.Base.TypeId != "Sketcher::SketchObject":
            return False

        #test sketch
        if not self.isSketchSupported(fcObj.Base):
            return False

        return True

    def isSketchSupported(self, sketch):
        supportedGeometryTypes = [Part.LineSegment, Part.Circle, Part.Point]
        for line in sketch.Geometry:
            if not type(line) in supportedGeometryTypes and not line.Construction:
                return False

        return True

    def createMesh(self, fcObj, expPlacement, expPigment, expClose, expMeshDef): #create pov mesh from object
        povCode = ""

        if expMeshDef:
            mesh = 0

            if fcObj.isDerivedFrom("Mesh::Feature"): #is fcObj a mesh
                mesh = fcObj.Mesh
            else:
                try:
                    shape = fcObj.Shape.copy()
                    try:
                        angularDeflection = fcObj.ViewObject.AngularDeflection.getValueAs("rad").Value
                    except:
                        angularDeflection = 0.5
                    deviation = fcObj.ViewObject.Deviation

                    try:
                        mesh = MeshPart.meshFromShape(Shape = shape, LinearDeflection = deviation, AngularDeflection = angularDeflection, Relative = False)
                    except:
                        mesh = MeshPart.meshFromShape(shape, deviation, angularDeflection)

                except:
                    return ""


            if not mesh or len(mesh.Topology[0]) == 0 or len(mesh.Topology[1]) == 0:
                #warningMessage = "\n\nNo mesh created - Object " + fcObj.Label + " won't be rendered"
                #App.Console.PrintWarning(warningMessage)
                return ""

            #create mesh2 object
            povMesh = "#declare " + stringCorrection(fcObj.Label) + "_mesh ="
            povMesh += "\nmesh2 {\n\tvertex_vectors {\n"

            #create vertex_vectors
            numOfVertex = len(mesh.Topology[0])
            povMesh += "\t\t" + str(numOfVertex)

            for point in mesh.Topology[0]:
                povMesh += ",\n\t\t<" + str(point.x) + ", " + str(point.y) + ", " + str(point.z) + ">"
            povMesh += "\n\t}\n\n"

            #create face_indices
            povMesh += "\tface_indices {\n"
            numOfTriangles = len(mesh.Topology[1])
            povMesh += "\t\t" + str(numOfTriangles)

            for triangle in mesh.Topology[1]:
                povMesh += ",\n\t\t<" + str(triangle[0]) + ", " + str(triangle[1]) + ", " + str(triangle[2]) + ">"
            povMesh += "\n\t}\n\n"

            #add inside vector
            povMesh += "\tinside_vector <1, 1, 1>\n"

            povMesh += "}\n\n"

            #write mesh in inc file
            self.meshFileContent += povMesh

        #return pov code
        povCode += "\nobject { " + stringCorrection(fcObj.Label) + "_mesh\n"
        pigment = self.getPigment(fcObj)

        if expPlacement == False: #meshes are already translated, so if they shouldnt translated, they translated back
            translation = self.getTranslation(fcObj)
            if translation != "": #test if the object is translated
                povCode += "\t" + translation + " * (-1)\n"
            
            rotation = self.getInvertedRotation(fcObj)
            if rotation != "": #test if the object is rotated
                povCode += rotation.replace("\n", "\t\n")

        if pigment != "": #test if the object has the standard pigment
            povCode += "\t" + pigment + "\n"

        if expClose:
            povCode += "}\n"

        return povCode


    def getStatistics(self, objs): #get statistics about the model the user want to render
        statistics = ""
        noCsgCount = 0
        CsgCount = 0
        ParentCount = 0
        supportedTypeIds = ["Part::Sphere",
                            "Part::Box",
                            "Part::Torus",
                            "Part::Cylinder",
                            "Part::Cone",
                            "Part::Ellipsoid",
                            "Part::Plane",
                            "Part::Cut",
                            "Part::MultiFuse", "Part::Fuse",
                            "Part::MultiCommon", "Part::Common",
                            "Part::Extrusion",
                            "PartDesign::Body"
                            "PartDesign::Pad",
                            "PartDesign::Pocket",
                            "Sketcher::SketchObject",
                            "App::DocumentObjectGroup",
                            "App:Part",
                            "Part::Compound",
                            "Image::ImagePlane"]
        supportedNames = ["Array", "Clone"]

        for obj in objs:
            if not obj.TypeId in supportedTypeIds and not self.isNameSupported(obj.Name, supportedNames):
                noCsgCount = noCsgCount + 1
            else:
                CsgCount = CsgCount + 1
            if obj.InList == []:
                ParentCount = ParentCount + 1

        statistics += "Version of Macro: " + macroVersion + "\n"
        statistics += "Path to *.pov File: " + self.povPath + "\n"
        statistics += str(ParentCount) + " parent objects found in highest layer\n"
        statistics += "containing totally " + str(CsgCount + noCsgCount) + " objects\n"
        if noCsgCount != 0:
            statistics += "Your model contains " + str(noCsgCount) + " objects which aren't supported (will be represented as mesh).\n"

        if self.CamType == "Perspective":
            camInfo = "Perspective Camera\n"
        elif self.CamType == "Orthographic":
            camInfo = "Orthographic camera\n"
        else:
            camInfo = "Unknown camera type - rudimentary camera statement will be used\n"
        if self.incContent.find("camera") != -1:
            camInfo = "User defined camera found - FreeCAD camera will be commented out in *.pov file\n"

        statistics += camInfo
        statistics += "\n"

        return statistics

    def getLight(self): #get the FreeCAD light
        povLight = ""

        povLight += "light_source { CamPosition color rgb <0.5, 0.5, 0.5> }\n"

        return povLight

    def getBackground(self): #get the FreeCAD background
        bgColor1 = App.ParamGet("User parameter:BaseApp/Preferences/View").GetUnsigned('BackgroundColor')
        bgColor2 = App.ParamGet("User parameter:BaseApp/Preferences/View").GetUnsigned('BackgroundColor2')
        bgColor3 = App.ParamGet("User parameter:BaseApp/Preferences/View").GetUnsigned('BackgroundColor3')
        bgColor4 = App.ParamGet("User parameter:BaseApp/Preferences/View").GetUnsigned('BackgroundColor4')
        ViewDir = Gui.ActiveDocument.ActiveView.getViewDirection()

        AspectRatio = self.width / float(self.height)
        povBg = ""

        if self.CamType == "Orthographic":
            if AspectRatio >= 1:
                up = self.CamNode.height.getValue()
                right = up * AspectRatio
            else:
                right = self.CamNode.height.getValue()
                up = right/AspectRatio
            povBg += "\npolygon {\n"
            povBg += "\t5, <" + str(-right/2) + ", " + str(-up/2) + ">, <" + str(-right/2) + ", "
            povBg += str(up/2) + ">, <" + str(right/2) + ", " + str(up/2) + ">, <" + str(right/2) + ", " + str(-up/2)
            povBg += ">, <" + str(-right/2) + ", " + str(-up/2) + ">\n"
            povBg += "\tpigment {"
            if App.ParamGet("User parameter:BaseApp/Preferences/View").GetBool('Simple'):
                povBg += " color rgb" + self.uintColorToRGB(bgColor1) + " }\n"
            elif App.ParamGet("User parameter:BaseApp/Preferences/View").GetBool('Gradient'):
                povBg += "\n\t\tgradient y\n"
                povBg += "\t\tcolor_map {\n"
                povBg += "\t\t\t[ 0.00  color rgb" + self.uintColorToRGB(bgColor3) +" ]\n"
                povBg += "\t\t\t[ 0.05  color rgb" + self.uintColorToRGB(bgColor3) +" ]\n"
                if App.ParamGet("User parameter:BaseApp/Preferences/View").GetBool('UseBackgroundColorMid'):
                    povBg += "\t\t\t[ 0.50  color rgb" + self.uintColorToRGB(bgColor4) +" ]\n"
                povBg += "\t\t\t[ 0.95  color rgb" + self.uintColorToRGB(bgColor2) +" ]\n"
                povBg += "\t\t\t[ 1.00  color rgb" + self.uintColorToRGB(bgColor2) +" ]\n"
                povBg += "\t\t}\n"
                povBg += "\t\tscale <1," + str(up) + ",1>\n"
                povBg += "\t\ttranslate <0," + str(-up/2) + ",0>\n"
                povBg += "\t}\n"
            #color rgb<0,0,1>}\n"
            povBg += "\tfinish { ambient 1 diffuse 0 }\n"
            povBg += "\trotate <" + str(self.EulerCam[2]) + ", " + str(self.EulerCam[1]) + ", " + str(self.EulerCam[0]) + ">\n"
            povBg += "\ttranslate <" + str(self.CamPos.Base.x) + ", " + str(self.CamPos.Base.y) + ", " + str(self.CamPos.Base.z) + ">\n"
            povBg += "\ttranslate <" + str(ViewDir[0]*100000) + ", " + str(ViewDir[1]*100000) + ", " + str(ViewDir[2]*100000) + ">\n"
            povBg += "}\n"

        povBg += "sky_sphere {\n\tpigment {\n"
        if App.ParamGet("User parameter:BaseApp/Preferences/View").GetBool('Simple'):
            povBg += "\t\tcolor rgb" + self.uintColorToRGB(bgColor1) + "\n"

        elif App.ParamGet("User parameter:BaseApp/Preferences/View").GetBool('Gradient'):
            povBg += "\t\tgradient z\n"
            povBg += "\t\tcolor_map {\n"
            povBg += "\t\t\t[ 0.00  color rgb" + self.uintColorToRGB(bgColor3) +" ]\n"
            povBg += "\t\t\t[ 0.30  color rgb" + self.uintColorToRGB(bgColor3) +" ]\n"
            if App.ParamGet("User parameter:BaseApp/Preferences/View").GetBool('UseBackgroundColorMid'):
                povBg += "\t\t\t[ 0.50  color rgb" + self.uintColorToRGB(bgColor4) +" ]\n"
            povBg += "\t\t\t[ 0.70  color rgb" + self.uintColorToRGB(bgColor2) +" ]\n"
            povBg += "\t\t\t[ 1.00  color rgb" + self.uintColorToRGB(bgColor2) +" ]\n"
            povBg += "\t\t}\n"
            povBg += "\t\tscale 2\n"
            povBg += "\t\ttranslate -1\n"
            povBg += "\t\trotate<" + str(self.EulerCam[2]-90) + ", " + str(self.EulerCam[1]) + ", " + str(self.EulerCam[0]) + ">\n"
        povBg += "\t}\n}\n"

        return povBg

    def getCam(self): #get the FreeCAD camera
        AspectRatio = self.width / float(self.height)

        PovCam = ""
        incCamera = False

        PovCamType = ""
        PovCamAngle = ""
        PovCamUp = ""
        PovCamRight = ""

        if self.CamType == "Perspective":
            PovCamUp = "<0, 0, 1>"
            PovCamRight = "<" + "{0:1.2f}".format(AspectRatio) + ", 0, 0>"

            if AspectRatio <= 1:
                CamAngle = 45
            else:
                CamAngle = math.degrees(math.atan2(AspectRatio/2,1.2071067812))*2
            PovCamAngle = "\tangle {0:1.2f}".format(CamAngle) + "\n"

        elif self.CamType == "Orthographic":
            if AspectRatio >= 1:
                up = up = self.CamNode.height.getValue()
                right = up*AspectRatio
            else:
                right = self.CamNode.height.getValue()
                up = right/AspectRatio
            PovCamType = "\torthographic\n"
            PovCamUp = "< 0, 0, " + "{0:1.2f}".format(up) + ">"
            PovCamRight = "<" + "{0:1.2f}".format(right) +", 0, 0>"

        PovCam += "#declare CamUp = " + PovCamUp + ";\n"
        PovCam += "#declare CamRight = " + PovCamRight + ";\n"
        PovCam += "#declare CamRotation = <" + str(self.EulerCam[2]-90) + ", " + str(self.EulerCam[1]) + ", " + str(self.EulerCam[0]) + ">;\n"
        PovCam += "#declare CamPosition = <" + str(self.CamPos.Base.x) + ", " + str(self.CamPos.Base.y) + ", " + str(self.CamPos.Base.z) + ">;\n"

        if self.incContent.find("camera") != -1:
            incCamera = True
            PovCam += "/*"

        PovCam += "camera {\n"
        PovCam += PovCamType
        PovCam += "\tlocation <0, 0, 0>\n"
        PovCam += "\tdirection <0, 1, 0>\n"
        PovCam += "\tup CamUp\n"
        PovCam += "\tright CamRight\n"
        PovCam += "\trotate CamRotation\n"
        PovCam += "\ttranslate CamPosition\n"
        PovCam += PovCamAngle
        PovCam += "}\n"
        if incCamera:
            PovCam += "*/\n"

        return PovCam


    def getTranslation(self, fcObj): #get the translation of an object
        translation = ""
        x = fcObj.Placement.Base.x #get the position in every axis
        y = fcObj.Placement.Base.y
        z = fcObj.Placement.Base.z
        if x != 0 or y != 0 or z != 0: #test whether the position is 0,0,0
            translation += "translate <" + str(x) + ", " + str(y) + ", " + str(z) + ">" #create translation vector

        return translation

    def getRotation(self, fcObj): #get the rotation of an object
        rotate = ""
        eulerRot = fcObj.Placement.Rotation.toEuler() #convert the rotation to euler angles
        x = eulerRot[2] #get rotation in every axis
        y = eulerRot[1]
        z = eulerRot[0]

        #if fcObj is a torus it is necessary to rotate it in x axis
        if fcObj.TypeId == "Part::Torus" or (fcObj.Name.startswith("Clone") and fcObj.OutList[0].TypeId == "Part::Torus"):
            x += 90
        elif fcObj.TypeId == "Sketcher::SketchObject":
            x -= 90

        if x != 0 or y != 0 or z != 0:
            rotate = "rotate <" + str(x) + ", " + str(y)+ ", "  + str(z) + ">" #create roation vector

        return rotate

    def getInvertedRotation(self, fcObj):
        rotate = ""
        eulerRot = fcObj.Placement.Rotation.toEuler() #convert the rotation to euler angles
        x = eulerRot[2] #get rotation in every axis
        y = eulerRot[1]
        z = eulerRot[0]

        #if fcObj is a torus it is necessary to rotate it in x axis
        if fcObj.TypeId == "Part::Torus" or (fcObj.Name.startswith("Clone") and fcObj.OutList[0].TypeId == "Part::Torus"):
            x += 90
        elif fcObj.TypeId == "Sketcher::SketchObject":
            x -= 90

        rotate = "\n"

        if z != 0:
            rotate += "rotate <0, 0, " + str(-z) + ">\n"
        if y != 0:
            rotate += "rotate <0, " + str(-y) + ", 0>\n"
        if x != 0:
            rotate += "rotate <" + str(-x) + ", 0, 0>\n"

        return rotate

    def getPigment(self, fcObj): #get the pigment of an object
        appObject = fcObj.ViewObject
        material = ""
        pigment = ""
        transparency = ""
        finish = ""
        ambient = ""
        emission = ""
        phong = ""
        if appObject.Transparency != 0:
            transparency += " transmit " + str(appObject.Transparency / float(100))
        ShapeColorRGB = "<{0:1.3f}, {1:1.3f}, {2:1.3f}>".format(appObject.ShapeColor[0],appObject.ShapeColor[1],appObject.ShapeColor[2])
        if transparency != "" or ShapeColorRGB != self.uintColorToRGB(self.DefaultShapeColor):
            pigment += "\tpigment { color rgb " + ShapeColorRGB + transparency + " }\n"
        material += pigment
        if appObject.ShapeMaterial.AmbientColor != (0.20000000298023224,0.20000000298023224,0.20000000298023224,0):
            ambient += "ambient rgb<"
            ambient += "{0:1.3f}, {1:1.3f}, {2:1.3f}".format(appObject.ShapeMaterial.AmbientColor[0],
                                                             appObject.ShapeMaterial.AmbientColor[1],
                                                             appObject.ShapeMaterial.AmbientColor[2])
            ambient += ">"
        if appObject.ShapeMaterial.EmissiveColor != (0,0,0,0):
            emission += "emission rgb<"
            emission += "{0:1.3f}, {1:1.3f}, {2:1.3f}".format(appObject.ShapeMaterial.EmissiveColor[0],
                                                              appObject.ShapeMaterial.EmissiveColor[1],
                                                              appObject.ShapeMaterial.EmissiveColor[2])
            emission += ">"
        if appObject.ShapeMaterial.SpecularColor != (0,0,0,0):
            phong += "phong "
            phong += "{0:1.2f}".format((appObject.ShapeMaterial.SpecularColor[0] +
                                        appObject.ShapeMaterial.SpecularColor[1] +
                                        appObject.ShapeMaterial.SpecularColor[2]) / 3)
            phong += " phong_size "
            phong += str(appObject.ShapeMaterial.Shininess * 50)
            phong += " "
        if ambient != "" or emission != "" or  phong != "":
            finish = "finish {"
            finish += "\n\t" + ambient
            finish += "\n\t" + emission
            finish += "\n\t" + phong
            finish += "\n}\n"
        material += finish

        if self.texIncContent.find("#declare " + stringCorrection(fcObj.Label) + "_material_hollow") != -1:
            material = "\nhollow\nmaterial {" + stringCorrection(fcObj.Label) + "_material_hollow }\n"
        
        elif self.texIncContent.find("#declare " + stringCorrection(fcObj.Label) + "_") != -1:
            if self.texIncContent.find("#declare " + stringCorrection(fcObj.Label) + "_material") != -1:
                material = "\nmaterial {" + stringCorrection(fcObj.Label) + "_material }\n"
            elif self.texIncContent.find("#declare " + stringCorrection(fcObj.Label) + "_texture") != -1:
                material = "\ntexture {" + stringCorrection(fcObj.Label) + "_texture }\n"
            elif self.texIncContent.find("#declare " + stringCorrection(fcObj.Label) + "_pigment") != -1:
                material = "\npigment {" + stringCorrection(fcObj.Label) + "_pigment }\n"
            else:
                return ""

        if self.incContent.find("#declare " + stringCorrection(fcObj.Label) + "_material") != -1:
            material = "\nmaterial {" + stringCorrection(fcObj.Label) + "_material }\n"
        
        
            
        return material


    def writeFile(self, povText): #write the final pov file
        #povText: the code for POV-Ray
        try:
            file = open(self.povPath, "w+") #XXX open file (Really "w+"?)
            file.write(povText) #write code
            file.close() #close file
        except:
            return -1

    def openPovRay(self): #start POV-Ray
        povExec = App.ParamGet("User parameter:BaseApp/Preferences/Mod/Raytracing").GetString('PovrayExecutable')
        if os.path.isfile(povExec) == False:
            povExec = App.ParamGet("User parameter:BaseApp/Preferences/Mod/Render").GetString('PovrayExecutable')
            if os.path.isfile(povExec) == False:
                errorText = "To start the rendering you must\n"
                errorText += "set the path to the POV-Ray executable\n"
                errorText += "either in the settings of Render workbench\n"
                errorText += "or in the settings of Raytracing workbench\n"
                showError(errorText, "POV-Ray executable not found")
                return -1
            povOptions = App.ParamGet("User parameter:BaseApp/Preferences/Mod/Render").GetString('OutputParameters')
        povOptions = App.ParamGet("User parameter:BaseApp/Preferences/Mod/Raytracing").GetString('OutputParameters')

        #create output directory
        os.chdir(str(self.directory))

        #write user options to ini file
        iniHandler = open(self.iniPath, "a")
        iniHandler.write("\n;User Options from FreeCAD Settings\n" + povOptions)
        iniHandler.close()

        #start povray
        subprocess.call([povExec, self.iniName])

        self.checkErrFile()

    def checkErrFile(self): #check error file for errors
        error = ""
        inPovFile = False
        #open error file
        if os.path.isfile(self.errorPath) == True:
            file = open(self.errorPath, "r")
            #read error file
            error = file.read()
            file.close()
        #is there any content in the file
        if error != "": #error occured
            #show error message
            errorText = ""
            errorText += "An error occured while rendering:\n-----------------------------------------\n"
            errorText += error
            errorText += "\n-----------------------------------------\n"
            errorText += "If the error occured in the pov file or the mesh file, please report a bug to us."
            errorText += "(See the wiki, link is in the help tab of the dialog)\n\n"
            errorText += "You can see the error message in the error file too."
            showError(errorText, "An error ocurred while rendering")
        else:
            self.delErrorFile();

    def delErrorFile(self): #delete error file
        os.remove(self.errorPath)

    def repairRotation(self, objs): #repair the rotation of objects (likely a bug in FreeCAD)
        for obj in objs:
            if hasattr(obj, 'Placement'):
                ObjLocation = obj.Placement
                posX = ObjLocation.Base.x
                posY = ObjLocation.Base.y
                posZ = ObjLocation.Base.z
                rotX = ObjLocation.Rotation.Axis[0]
                rotY = ObjLocation.Rotation.Axis[1]
                rotZ = ObjLocation.Rotation.Axis[2]
                rotAngle = math.degrees(ObjLocation.Rotation.Angle)
                obj.Placement = App.Placement(App.Vector(posX, posY, posZ), App.Rotation(App.Vector(rotX, rotY, rotZ), rotAngle), App.Vector(0, 0, 0))

    def exportFcView(self): #export the current FreeCAD view like Tools / Save Picture...
        Gui.ActiveDocument.ActiveView.saveImage(self.fcViewPath, self.width, self.height)

    def hasPartAsParent(self, fcObj):
        for parent in fcObj.InList:
            if parent.TypeId == "App::Part":
                return True

        return False

    def hasBodyAsParent(self, fcObj):
        for parent in fcObj.InList:
            if parent.TypeId == "PartDesign::Body":
                return True

        return False

    def uintColorToRGB(self, uintColor): #convert uint color to a rgb color
        Blue = (uintColor >> 8) & 255
        Green = (uintColor >> 16) & 255
        Red = (uintColor >> 24) & 255
        rgbString = "<{0:1.3f}, {1:1.3f}, {2:1.3f}>".format(Red / float(255), Green / float(255), Blue / float(255))
        return rgbString

    def delComments(self, code): #delete the comments in incContent
        #delete big comments
        while code.find("/*") is not -1:
            comStart = code.find("/*")
            comEnd = code.find("*/", comStart + 2)

            if comEnd is -1:
                App.Console.PrintError("Unable to delete all comments in the inc file!\nThere is an unclosed multi line comment.\n")
                return
            code = code[0:comStart] + code[comEnd + 2:]

        #delete little comments
        while code.find("//") is not -1:
            comStart = code.find("//")
            comEnd = code.find("\n", comStart + 2)

            if comEnd is -1:
                App.Console.PrintError("Unable to delete all comments in the inc file!\nThere is a misstake in a one line comment")
                return
            code = code[0:comStart] + code[comEnd:]
        return code

    def isNameSupported(self, objName, supportedNames): #is fcObj.Name part of the supported names
        for name in supportedNames:
            if objName.startswith(name):
                return True

        return False


class GUI(QtGui.QDialog): #the pyside class for the dialog window
    def __init__(self):
        super(GUI, self).__init__()
        self.initUI()
        self.setDefaultValues()

    def initUI(self): #create the objects in the dialog window
        self.setWindowTitle("Export to POV-Ray")

        #pov file selection
        self.pathLineEdit = QtGui.QLineEdit()
        self.pathLineEdit.setPlaceholderText("Path to INI File")
        self.pathLineEdit.setToolTip("Path to the INI file (kind of a project file)")
        self.pathLineEdit.setFixedWidth(300)
        self.pathLineEdit.textChanged.connect(self.checkPath)

        self.openFileDialogButton = QtGui.QPushButton("...")
        self.openFileDialogButton.clicked.connect(self.openFileDialog)
        self.openFileDialogButton.setToolTip("Open file dialog for choosing a INI file")

        self.warnLabel = QtGui.QLabel("")
        self.warnLabel.setStyleSheet("QLabel { color : #ff0000; }")

        self.horizLayout1 = QtGui.QGridLayout()
        self.horizLayout1.addWidget(self.pathLineEdit, 0, 0)
        self.horizLayout1.addWidget(self.openFileDialogButton, 0, 1)
        self.horizLayout1.addWidget(self.warnLabel, 1, 0, 1, 2)

        self.pathGroup = QtGui.QGroupBox("Output File Selection")
        self.pathGroup.setLayout(self.horizLayout1)

        #Width & Height of rendered image
        self.imageWidthLabel = QtGui.QLabel("Width")
        self.imageWidth = QtGui.QSpinBox()
        self.imageWidth.setMinimum(1)
        self.imageWidth.setMaximum(999999)
        self.imageWidth.setSuffix(" px")
        self.imageWidth.setValue(800)
        self.imageWidth.setToolTip("Width of the rendered image in pixels")
        self.imageHeightLabel = QtGui.QLabel("Height")
        self.imageHeight = QtGui.QSpinBox()
        self.imageHeight.setMinimum(1)
        self.imageHeight.setMaximum(999999)
        self.imageHeight.setSuffix(" px")
        self.imageHeight.setValue(600)
        self.imageHeight.setToolTip("Height of the rendered image in pixels")

        self.vertLayout1 = QtGui.QVBoxLayout()
        self.vertLayout1.addWidget(self.imageWidthLabel)
        self.vertLayout1.addWidget(self.imageWidth)
        self.vertLayout1.addWidget(self.imageHeightLabel)
        self.vertLayout1.addWidget(self.imageHeight)
        self.WHImageGroup = QtGui.QGroupBox("Width and Height of rendered Image")
        self.WHImageGroup.setLayout(self.vertLayout1)

        #Options
        self.expBg = QtGui.QCheckBox("Export FreeCAD Background")
        self.expBg.setToolTip("Export the FreeCAD background like you see it (editable via the settings)<br>Define your own background if you uncheck this option")
        
        self.expLight = QtGui.QCheckBox("Export FreeCAD Light")
        self.expLight.setToolTip("Export the light FreeCAD uses. Define your own light if you uncheck this option")

        self.repRot = QtGui.QCheckBox("Repair Rotation")
        self.repRot.setToolTip("Repair the rotation of all objects. Visit the Help tab for more information.")
        
        self.expFcView = QtGui.QCheckBox("Export FreeCAD View")
        self.expFcView.setToolTip("Take a screenshot of the scene view and save it with the same resolution as the image")

        self.vertLayout2 = QtGui.QVBoxLayout()
        self.vertLayout2.addWidget(self.expBg)
        self.vertLayout2.addWidget(self.expLight)
        self.vertLayout2.addWidget(self.repRot)
        self.vertLayout2.addWidget(self.expFcView)
        self.optionGroups = QtGui.QGroupBox("Options")
        self.optionGroups.setLayout(self.vertLayout2)

        #add widgets to the main layout
        self.mainLayout = QtGui.QVBoxLayout()
        self.mainLayout.addWidget(self.pathGroup)
        self.mainLayout.addWidget(self.WHImageGroup)
        self.mainLayout.addWidget(self.optionGroups)

        #Texture Tab
        self.initTextureTab()

        #create macro group
        self.macroGroup = QtGui.QGroupBox("")
        self.macroGroup.setLayout(self.mainLayout)

        #crate help group
        self.helpLabel = QtGui.QLabel("")

        #create tabs
        self.tabs = QtGui.QTabWidget(self)
        self.tabs.addTab(self.macroGroup, "Macro")
        self.tabs.addTab(self.textureWidget, "Textures")
        self.tabs.addTab(self.helpLabel, "Help")

        # ok cancel buttons
        self.buttonBox = QtGui.QDialogButtonBox(QtGui.QDialogButtonBox.Ok | QtGui.QDialogButtonBox.Cancel)
        self.buttonBox.accepted.connect(self.onOk)
        self.buttonBox.rejected.connect(self.onCancel)

        self.wrapLayout = QtGui.QVBoxLayout()
        self.wrapLayout.addWidget(self.tabs)
        self.wrapLayout.addWidget(self.buttonBox)
        self.setLayout(self.wrapLayout)
        self.show()

    def initTextureTab(self): #create all necessary stuff for texture tab and connect signals
        self.textureLayout = QtGui.QVBoxLayout() #the wrapper layout for the tab
        
        self.addObjectsTexturesLists() #add the two lists at the top
        self.addScaleRotateTranslate() #add the menu for scaling and rotating at the bottom
        self.addPreview()

        # signals and slots
        self.connectSignals()

        self.previewDisableCheckBox.stateChanged.connect(self.updateSelectedListObject)
        self.zoomIn.pressed.connect(self.largerPreview)
        self.zoomOut.pressed.connect(self.smallerPreview)

        #set layouts
        self.textureLayout.addWidget(self.listWidget)
        self.textureLayout.addWidget(self.textureSettingsWidget)
        self.textureLayout.addWidget(self.previewWidget)

        self.textureWidget = QtGui.QWidget() #wrapper widget for texture tab
        self.textureWidget.setLayout(self.textureLayout)

    def largerPreview(self):
        self.previewWidth += 40
        self.previewHeight += 30

        self.updateSelectedListObject()

    def smallerPreview(self):
        if self.previewWidth < 45:
            return

        self.previewWidth -= 40
        self.previewHeight -= 30

        self.updateSelectedListObject()

    def connectSignals(self): #connect all necessary signals for the texture tab
        self.objectList.itemSelectionChanged.connect(self.updateTextureSettings)
        self.textureList.itemSelectionChanged.connect(self.updateSelectedListObject)

        self.scaleX.valueChanged.connect(self.updateSelectedListObject)
        self.scaleY.valueChanged.connect(self.updateSelectedListObject)
        self.scaleZ.valueChanged.connect(self.updateSelectedListObject)

        self.rotationX.valueChanged.connect(self.updateSelectedListObject)
        self.rotationY.valueChanged.connect(self.updateSelectedListObject)
        self.rotationZ.valueChanged.connect(self.updateSelectedListObject)

        self.translationX.valueChanged.connect(self.updateSelectedListObject)
        self.translationY.valueChanged.connect(self.updateSelectedListObject)
        self.translationZ.valueChanged.connect(self.updateSelectedListObject)

    def disconnectSignals(self): #disconnect all signals for the texture tab
        self.objectList.itemSelectionChanged.disconnect()
        self.textureList.itemSelectionChanged.disconnect()

        self.scaleX.valueChanged.disconnect()
        self.scaleY.valueChanged.disconnect()
        self.scaleZ.valueChanged.disconnect()

        self.rotationX.valueChanged.disconnect()
        self.rotationY.valueChanged.disconnect()
        self.rotationZ.valueChanged.disconnect()
        
        self.translationX.valueChanged.disconnect()
        self.translationY.valueChanged.disconnect()
        self.translationZ.valueChanged.disconnect()

    def addObjectsTexturesLists(self): #add the two lists with the objects and textures
        self.listWidget = QtGui.QWidget() #wrapper widget for the two lists
        self.listLayout = QtGui.QGridLayout() #wrapper layout for the two lists

        #texture list
        self.textureList = QtGui.QTreeWidget()
        self.textureList.setHeaderLabel("Type of Predefined")

        self.textureListLabel = QtGui.QLabel("<b>Texture</b>")

        self.predefines = []
        #add FreeCAD texture
        self.fcTexItem = QtGui.QTreeWidgetItem(self.textureList, ["FreeCAD Texture"])
        self.predefines.append(Predefined("FreeCAD Texture", None, None, None, None, None, None, None, "", self.fcTexItem))
        self.fcTexItem.setSelected(True)

        #get the predefined.xml
        predefinedPath = App.ParamGet("User parameter:BaseApp/Preferences/Macro").GetString('MacroPath') #get macro path
        predefinedPath += "/predefined.xml"

        predefined = xml.parse(predefinedPath).getroot()
        categories = predefined.getchildren()

        #read the predefined.xml and add the predefined defined in the XML
        for categorie in categories:
            #categorieItem = QtGui.QTreeWidgetItem(self.textureList, [categorie.tag])
            #predefs = categorie.getchildren()
            self.predefXmlToList(categorie, self.textureList)


        #add the list to the layouts and widgets
        self.listLayout.addWidget(self.textureListLabel, 0, 1)
        self.listLayout.addWidget(self.textureList, 1, 1)

        self.listWidget.setLayout(self.listLayout)

        #object list
        self.objectList = QtGui.QListWidget()

        self.objectListLabel = QtGui.QLabel("<b>Object</b>")

        #get objects
        objs = App.ActiveDocument.Objects
        self.listFcObjects = []
        for obj in objs:
            #has object a shape color
            try:
                obj.ViewObject.ShapeColor
                shapeColor = True
            except:
                shapeColor = False
            #has object a shape
            try:
                obj.Shape
                shape = True
            except:
                shape = False

            #test for the conditions for a object for the object list
            if obj.ViewObject.Visibility and shapeColor and shape:
                self.listFcObjects.append(obj)

        self.listObjects = []
        #create the listObjects
        for obj in self.listFcObjects:
            try:
                listItem = QtGui.QListWidgetItem(obj.ViewObject.Icon, obj.Label)
            except:
                listItem = QtGui.QListWidgetItem(obj.Label)
            predefined = self.predefines[0]
            self.listObjects.append(ListObject(obj, listItem, self.predefines[0], 1, 1, 1, 0, 0, 0, 0, 0, 0))

            self.objectList.addItem(listItem)
        
        #add the object list to the layouts
        self.listLayout.addWidget(self.objectListLabel, 0, 0)
        self.listLayout.addWidget(self.objectList, 1, 0)

    def predefXmlToList(self, xmlNode, parentNode):
        childNodes = xmlNode.getchildren()

        if childNodes == []:
            treeItem = QtGui.QTreeWidgetItem(parentNode, [xmlNode.text])
            #get all attributes
            attr = xmlNode.attrib
            if "material" in attr:
                material = attr["material"]
            else:
                material = ""

            if "texture" in attr:
                texture = attr["texture"]
            else:
                texture = ""

            if "pigment" in attr:
                pigment = attr["pigment"]
            else:
                pigment = ""

            if "finish" in attr:
                finish = attr["finish"]
            else:
                finish = ""
            
            if "normal" in attr:
                normal = attr["normal"]
            else:
                normal = ""

            if "interior" in attr:
                interior = attr["interior"]
            else:
                interior = ""
                
            if "media" in attr:
                media = attr["media"]
            else:
                media = ""    

            if "inc" in attr:
                inc = attr["inc"]
            else:
                inc = ""

            self.predefines.append(Predefined(xmlNode.text, material, texture, pigment, finish, normal, interior, media, inc, treeItem))

        else:
            categorieItem = QtGui.QTreeWidgetItem(parentNode, [xmlNode.tag])
            for node in childNodes:
                #call method for child nodes
                self.predefXmlToList(node, categorieItem)

    def addScaleRotateTranslate(self): #add the scale and rotate menu
        # scale, rotate, preview
        self.textureSettingsWidget = QtGui.QWidget()
        self.textureSettingsLayout = QtGui.QGridLayout()

        # scale
        self.scalingLabel = QtGui.QLabel("Scale")
        self.textureSettingsLayout.addWidget(self.scalingLabel, 0, 0)

        self.scaleX = QtGui.QDoubleSpinBox()
        self.scaleX.setMaximum(9999999)
        self.scaleX.setMinimum(-9999999)
        self.scaleX.setPrefix("x: ")
        self.textureSettingsLayout.addWidget(self.scaleX, 0, 1)

        self.scaleY = QtGui.QDoubleSpinBox()
        self.scaleY.setMaximum(9999999)
        self.scaleY.setMinimum(-9999999)
        self.scaleY.setPrefix("y: ")
        self.textureSettingsLayout.addWidget(self.scaleY, 0, 2)

        self.scaleZ = QtGui.QDoubleSpinBox()
        self.scaleZ.setMaximum(9999999)
        self.scaleZ.setMinimum(-9999999)
        self.scaleZ.setPrefix("z: ")
        self.textureSettingsLayout.addWidget(self.scaleZ, 0, 3)

        # rotate
        self.rotationLabel = QtGui.QLabel("Rotate")
        self.textureSettingsLayout.addWidget(self.rotationLabel, 1, 0)

        self.rotationX = QtGui.QDoubleSpinBox()
        self.rotationX.setMaximum(360)
        self.rotationX.setMinimum(-360)
        self.rotationX.setPrefix("x: ")
        self.rotationX.setSuffix(" deg")
        self.textureSettingsLayout.addWidget(self.rotationX, 1, 1)

        self.rotationY = QtGui.QDoubleSpinBox()
        self.rotationY.setMaximum(360)
        self.rotationY.setMinimum(-360)
        self.rotationY.setPrefix("y: ")
        self.rotationY.setSuffix(" deg")
        self.textureSettingsLayout.addWidget(self.rotationY, 1, 2)

        self.rotationZ = QtGui.QDoubleSpinBox()
        self.rotationZ.setMaximum(360)
        self.rotationZ.setMinimum(-360)
        self.rotationZ.setPrefix("z: ")
        self.rotationZ.setSuffix(" deg")
        self.textureSettingsLayout.addWidget(self.rotationZ, 1, 3)

        # translation
        self.translationLabel = QtGui.QLabel("Translate")
        self.textureSettingsLayout.addWidget(self.translationLabel, 2, 0)

        self.translationX = QtGui.QDoubleSpinBox()
        self.translationX.setMaximum(9999999)
        self.translationX.setMinimum(-9999999)
        self.translationX.setPrefix("x: ")
        #self.translationX.setSuffix(" deg")
        self.textureSettingsLayout.addWidget(self.translationX, 2, 1)

        self.translationY = QtGui.QDoubleSpinBox()
        self.translationY.setMaximum(9999999)
        self.translationY.setMinimum(-9999999)
        self.translationY.setPrefix("y: ")
        #self.translationY.setSuffix(" deg")
        self.textureSettingsLayout.addWidget(self.translationY, 2, 2)

        self.translationZ = QtGui.QDoubleSpinBox()
        self.translationZ.setMaximum(9999999)
        self.translationZ.setMinimum(-9999999)
        self.translationZ.setPrefix("z: ")
        #self.translationZ.setSuffix(" deg")
        self.textureSettingsLayout.addWidget(self.translationZ, 2, 3)

        self.textureSettingsWidget.setLayout(self.textureSettingsLayout)

    def addPreview(self):
        #disable checkbox
        self.previewDisableCheckBox = QtGui.QCheckBox("Disable Live Preview")

        #zoom buttons
        self.zoomIn = QtGui.QPushButton("Zoom In")
        self.zoomOut = QtGui.QPushButton("Zoom Out")

        #preview setting layout
        self.previewSettingsLayout = QtGui.QHBoxLayout()
        self.previewSettingsLayout.addWidget(self.previewDisableCheckBox)
        self.previewSettingsLayout.addWidget(self.zoomIn)
        self.previewSettingsLayout.addWidget(self.zoomOut)

        #preview image
        self.previewLabel = QtGui.QLabel()
        self.previewLabel.setStyleSheet("QLabel { color : #ff0000; }")

        #main layout
        self.previewLayout = QtGui.QVBoxLayout()
        self.previewLayout.addLayout(self.previewSettingsLayout)
        self.previewLayout.addWidget(self.previewLabel)

        self.previewWidget = QtGui.QWidget()
        self.previewWidget.setLayout(self.previewLayout)

    def updateTextureSettings(self): #get the selected object and select the right predefined
        self.disconnectSignals()
        listObj = self.getSelectedListObject() #get the current selected object

        if listObj == -1: #is an object selected
            self.connectSignals()
            return -1

        #set all values for scaling and rotating
        self.scaleX.setValue(listObj.scaleX)
        self.scaleY.setValue(listObj.scaleY)
        self.scaleZ.setValue(listObj.scaleZ)

        self.rotationX.setValue(listObj.rotationX)
        self.rotationY.setValue(listObj.rotationY)
        self.rotationZ.setValue(listObj.rotationZ)

        self.translationX.setValue(listObj.translationX)
        self.translationY.setValue(listObj.translationY)
        self.translationZ.setValue(listObj.translationZ)

        #unselect all textures
        for predefine in self.predefines:
            predefine.treeItem.setSelected(False)

        #select the right predefined
        listObj.predefObject.treeItem.setSelected(True)

        #expand categories
        self.expandParentItems(listObj.predefObject.treeItem)

        self.renderPreview(listObj)

        self.connectSignals()

    def expandParentItems(self, item):
        parent = item.parent()
        if type(parent) == QtGui.QTreeWidgetItem:
            parent.setExpanded(True)
            self.expandParentItems(parent)

    def updateSelectedListObject(self): #get the selected predefined and update the listObject
        listObj = self.getSelectedListObject()
        predefine = self.getSelectedPredefined()
        if listObj == -1 or predefine == -1: #is no object or predefine selected
            if predefine == -1: #is only a categorie selected
                #expand and select predef under the categorie
                self.disconnectSignals()
                selectedItems = self.textureList.selectedItems()
                selected = selectedItems[0]
                selected.setSelected(False)
                selected.setExpanded(True)
                childItem = selected.child(0)
                self.connectSignals()
                childItem.setSelected(True)

            return -1 #abort

        #get the values for scaling and rotating
        listObj.scaleX = self.scaleX.value()
        listObj.scaleY = self.scaleY.value()
        listObj.scaleZ = self.scaleZ.value()

        listObj.rotationX = self.rotationX.value()
        listObj.rotationY = self.rotationY.value()
        listObj.rotationZ = self.rotationZ.value()

        listObj.translationX = self.translationX.value()
        listObj.translationY = self.translationY.value()
        listObj.translationZ = self.translationZ.value()

        listObj.predefObject = predefine #apply the read values to the predefObject in the listObject

        self.renderPreview(listObj)

    def renderPreview(self, listObj):
        if self.previewDisableCheckBox.isChecked():
            self.previewLabel.setText(" ")
            return

        if listObj.predefObject.material == None: #for FreeCAD materials
            self.previewLabel.setText("The FreeCAD texture is just like you see it in the FreeCAD scene\n so this texture is disabled.")
            return
        elif listObj.predefObject.media != "":
            self.previewLabel.setText("The texture is too complex for a preview and would need a lot of time\nso this texture is disabled.")
            return

        #write file
        fileContent =""
        fileContent += '#version 3.6; // 3.7\n'
        fileContent += 'global_settings { assumed_gamma 1.0 }\n'
        fileContent += '#default { finish { ambient 0.2 diffuse 0.9 } }\n'
        fileContent += '#default { pigment { rgb <0.871, 0.871, 0.871> } }\n'
        fileContent += '//------------------------------------------\n'
        fileContent += '#include "colors.inc"\n'
        fileContent += '#include "textures.inc"\n'
        fileContent += '#declare CamUp = <0, 0, 1>;\n'
        fileContent += '#declare CamRight = <1.33, 0, 0>;\n'
        fileContent += '#declare CamRotation = <-35.264390534, 1.9538003485e-05, 45.0000026303>;\n'
        fileContent += '#declare CamPosition = <25.9077129364, -15.9076957703, 20.907699585>;\n'
        fileContent += 'camera {\n'
        fileContent += '\tlocation <0, 0, 0>\n'
        fileContent += '\tdirection <0, 1, 0>\n'
        fileContent += '\tup CamUp\n'
        fileContent += '\tright CamRight\n'
        fileContent += '\trotate CamRotation\n'
        fileContent += '\ttranslate CamPosition\n'
        fileContent += '\tangle 57.82\n'
        fileContent += '}\n'
        fileContent += 'light_source { CamPosition color rgb <0.5, 0.5, 0.5> }\n'
        fileContent += 'sky_sphere {\n'
        fileContent += '\t\tpigment {\n'
        fileContent += '\t\tgradient z\n'
        fileContent += '\t\tcolor_map {\n'
        fileContent += '\t\t\t[0 rgb<0,0,0>]\n'
        fileContent += '\t\t\t[0.2 rgb<0,0,0>]\n'
        fileContent += '\t\t\t[0.75 rgb<1,1,1>]\n'
        fileContent += '\t\t\t[1 rgb<1,1,1>]\n'
        fileContent += '\t\t\t}\n'
        fileContent += '\t\tscale 2\n'
        fileContent += '\t\ttranslate -1\n'
        fileContent += '\t\t}\n'
        fileContent += '}\n'

        fileContent += self.listObjToPov(listObj, "predef")

        fileContent+= 'box { <0,0,0>, <10.0, 10.0, 10.0>\n'
        fileContent += '\ttranslate <5.0, 5.0, -5.0>\n'
        fileContent += '\tmaterial { predef_material }\n'
        fileContent += '}\n'
        fileContent += 'sphere { <0, 0, 0> 5 \n'
        fileContent += '\tmaterial { predef_material }\n'
        fileContent += '}\n'

        povFile = tempfile.NamedTemporaryFile(suffix=".pov") #pov file handler
        povFile.delete = False
        povFile.write(fileContent)

        povName = povFile.name
        povFile.close()

        #render
        povExec = App.ParamGet("User parameter:BaseApp/Preferences/Mod/Raytracing").GetString('PovrayExecutable')
        if os.path.isfile(povExec) == False:
            povExec = App.ParamGet("User parameter:BaseApp/Preferences/Mod/Render").GetString('PovrayExecutable')
            if os.path.isfile(povExec) == False:
                errorText = "To get a preview of the texture settings you must\n"
                errorText += "set the path to the POV-Ray executable\n"
                errorText += "either in the settings of Render workbench\n"
                errorText += "or in the settings of Raytracing workbench\n"
                showError(errorText, "POV-Ray executable not found")
                return -1
            povOptions = App.ParamGet("User parameter:BaseApp/Preferences/Mod/Render").GetString('OutputParameters')
        povOptions = App.ParamGet("User parameter:BaseApp/Preferences/Mod/Raytracing").GetString('OutputParameters')

        #start povray
        subprocess.call([povExec, "-d", "width=" + str(self.previewWidth), "height=" + str(self.previewHeight), povName])
        
        #update preview widget
        pixmap = QtGui.QPixmap(povName[:-4])
        self.previewLabel.setPixmap(pixmap)

    def getSelectedListObject(self): #get the current selected listObject
        for listObj in self.listObjects:
            if listObj.listItem.isSelected():
                return listObj

        return -1

    def getSelectedPredefined(self): #get the current selected predefined
        for predefine in self.predefines:
            if predefine.treeItem.isSelected():
                return predefine

        return -1

    def setDefaultValues(self): #set the default values of the input objects
        helpText = """
        <style>
        div { margin: 15;}
        </style>
        <div>
        <h3>General</h3>
        <p>This macro exports solid CSG primitives to POV-Ray.<br>
        The resulting POV code is readable and intended for further editing.<br>
        You can add user defined material for each object in a <br>
        seperate .inc file that won't be overwritten.</p>
        <h3>Pov File Selection</h3>
        <p>Select the ini file by typing the path into the text field or choose a .ini file <br>
        with the '…' button.<br>
        Be careful not to use spaces or special chars in pathname for POV-Ray compatibility.</p>
        <h3>Width and Height of the Image</h3>
        <p>Select the width and height in pixels of the image to be rendered with POV-Ray.</p>
        <h3>Options</h3>
        <h5>Export Background</h5>
        <p>Export the FreeCAD background</p>
        <h5>Export Light</h5>
        <p>Export the FreeCAD light. Define your own light in the inc file if you uncheck this option</p>
        <h5>Repair Rotation</h5>
        <p>Use this option if objects in your scene appear in a wrong rotation.<br>
        This is a workaround for a FreeCAD bug.</p>
        <h5>Export FreeCAD View</h5>
        <p>Export the current FreeCAD view in the same size as the image rendered by POV-Ray<br></p>
        <p>For more information look in our <a href='https://gitlab.com/usbhub/exporttopovray/blob/master/doc/index.md'>Wiki</a></p>
        </div>"""
        self.helpLabel.setText(helpText)
        self.helpLabel.setOpenExternalLinks(True)


        #get saved input
        settings = QtCore.QSettings("Usb Hub, DerUhrmacher", "Export to POV-Ray")
        settings.beginGroup("userInput")

        #set preview disable checkbox
        previewDisable = settings.value("previewDisable")
        if previewDisable != None:
            self.previewDisableCheckBox.setChecked(strToBool(previewDisable))
        else:
            self.previewDisableCheckBox.setChecked(True)

        previewWidth = settings.value("previewWidth")
        if previewWidth != None and previewWidth != 0 and previewWidth != -1:
            self.previewWidth = int(previewWidth)
        else:
            self.previewWidth = 300

        previewHeight = settings.value("previewHeight")
        if previewHeight != None and previewHeight != 0 and previewHeight != -1:
            self.previewHeight = int(previewHeight)
        else:
            self.previewHeight = 225

        if App.ActiveDocument.Name in settings.allKeys():
            iniPath = settings.value(App.ActiveDocument.Name)
        else:
            iniPath = -1

        settings.endGroup()

        if iniPath == -1:
            #set some good standardValues
            system = platform.system()
            if system == "Linux":
                defaultPath = "/home/"
            elif system == "Darwin":
                defaultPath = "/Users/"
            elif system == "Windows":
                defaultPath = "C:\\Users\\%UserName%\\"
            else:
                defaultPath = ""

            self.pathLineEdit.setText(defaultPath)

        else:
            self.pathLineEdit.setText(iniPath)

            #open ini file and extract CSV
            try:
                iniFile = open(iniPath, "r")
            except:
                App.Console.PrintError("Could not open ini file\n")
                return

            lines = iniFile.readlines()
            iniFile.close()
            csvLines = []

            for line in lines:
                if line.startswith(";"):
                    csvLines.append(line[1:])

            #parse CSV
            csvReader = csv.reader(csvLines, delimiter=',')
            for row in csvReader:
                if row[0].startswith("stg_"):
                    name = row[0][4:]

                    if name == "width":
                        self.imageWidth.setValue(int(row[1]))
                    elif name == "height":
                        self.imageHeight.setValue(int(row[1]))
                    elif name == "expBg":
                        self.expBg.setChecked(strToBool(row[1]))
                    elif name == "expLight":
                        self.expLight.setChecked(strToBool(row[1]))
                    elif name == "repRot":
                        self.repRot.setChecked(strToBool(row[1]))
                    elif name == "expFcView":
                        self.expFcView.setChecked(strToBool(row[1]))

                elif row[0].startswith("obj_"):
                    name = row[0][4:]
                    hash = row[1]

                    for listObj in self.listObjects:
                        if listObj.fcObj.Name == name:
                            for predef in self.predefines:
                                if predef.getHash() == hash:
                                    listObj.predefObject = predef
                                    break

                            listObj.scaleX = float(row[2])
                            listObj.scaleY = float(row[3])
                            listObj.scaleZ = float(row[4])

                            listObj.rotationX = float(row[5])
                            listObj.rotationY = float(row[6])
                            listObj.rotationZ = float(row[7])

                            listObj.translationX = float(row[8])
                            listObj.translationY = float(row[9])
                            listObj.translationZ = float(row[10])

    def openFileDialog(self): #open the file dialog for the pov file
        defaultPath = self.pathLineEdit.text()

        fileName = QtGui.QFileDialog.getSaveFileName(None, 'Select path and name of the *.ini file', defaultPath, "POV-Ray INI Files (*.ini)")

        if fileName and fileName != (u'', u''):
            self.pathLineEdit.setText(str(fileName[0]))

    def checkPath(self, path): #check if the path to pov file is valid
        if path.find(" ") == -1 and isAscii(path) == True and path != "" and path[-4:] == ".ini":
            self.buttonBox.button(QtGui.QDialogButtonBox.Ok).setEnabled(True)
            self.warnLabel.setText("")
        else:
            self.buttonBox.button(QtGui.QDialogButtonBox.Ok).setEnabled(False)
            if path == "":
                self.warnLabel.setText("Please type a path or get one with clicking on '…'")
            else:
                self.warnLabel.setText("Your path contains a space or a mutated vowel or is not a .ini file")

    def saveActiveDocName(self): #save the user inputs
        settings = QtCore.QSettings("Usb Hub, DerUhrmacher", "Export to POV-Ray")
        settings.beginGroup("userInput")
        settings.setValue(App.ActiveDocument.Name, self.pathLineEdit.text())
        settings.setValue("previewDisable", self.previewDisableCheckBox.isChecked())
        settings.setValue("previewWidth", self.previewWidth)
        settings.setValue("previewHeight", self.previewHeight)
        settings.endGroup()

    def writeTextureInc(self): #write the texture in content to a file
        self.texIncFile = open(self.renderSettings.texIncPath, "w")
        self.texIncFile.write(self.texIncContent)
        self.texIncFile.close()

    def writeIni(self):
        self.iniFile = open(self.renderSettings.iniPath, "w")
        self.iniFile.write(self.iniContent)
        self.iniFile.close()

    def settingsToCSV(self):
        csv = ""

        #add render settings
        csv += ";stg_povPath," + self.renderSettings.povPath + "\n"
        csv += ";stg_width," + str(self.renderSettings.width) + "\n"
        csv += ";stg_height," + str(self.renderSettings.height) + "\n"
        csv += ";stg_expBg," + str(self.renderSettings.expBg) + "\n"
        csv += ";stg_expLight," + str(self.renderSettings.expLight) + "\n"
        csv += ";stg_repRot," + str(self.renderSettings.repRot) + "\n"
        csv += ";stg_expFcView," + str(self.renderSettings.expFcView) + "\n"

        #add settings for every listobject
        for obj in self.listObjects:
            csv += ";obj_" + obj.fcObj.Name + "," + obj.predefObject.getHash() + ","
            csv += str(obj.scaleX) + "," + str(obj.scaleY) + "," + str(obj.scaleZ) + ","
            csv += str(obj.rotationX) + "," + str(obj.rotationY) + "," + str(obj.rotationZ) + ","
            csv += str(obj.translationX) + "," + str(obj.translationY) + "," + str(obj.translationZ) + "\n"

        self.csv = csv

    def createTexIncContent(self): #create the content of the texture inc file
        self.texIncContent = ""

        for obj in self.listObjects: #iterate over all listObjects
            self.texIncContent += self.listObjToPov(obj)

    def listObjToPov(self, obj, label=None):
        if label == None:
            label = obj.label

        if obj.predefObject.material == None: #for FreeCAD materials
            return "" #texture will be applied in the exporter class

        povContent = ""

        if obj.predefObject.inc != None and obj.predefObject.inc != "": #only if include file is necessary
            povContent += "#include \"" + obj.predefObject.inc + "\"\n"

        povContent += "#declare " + label + "_material"
        if obj.predefObject.media != "":
            povContent += "_hollow"
        povContent += " = material { "
        
        povContent += obj.predefObject.material + "\n"

        #pigment and texture
        if obj.predefObject.texture != "" or obj.predefObject.pigment != "" or obj.predefObject.normal != "" or obj.predefObject.finish != "":
            povContent += "\ttexture { " + obj.predefObject.texture + "\n"
            
            #pigment
            if obj.predefObject.pigment != "":
                povContent += "\t\tpigment { " + obj.predefObject.pigment + " }\n"

            #finish
            if obj.predefObject.finish != "":
                povContent += "\tfinish {\n\t" + obj.predefObject.finish + "\t}\n"

            #normal
            if obj.predefObject.normal != "":
                povContent += "\tnormal {\n\t" + obj.predefObject.normal + "\t}\n"

            povContent += "\t}\n"

        #interior and media
        if obj.predefObject.interior != "" or obj.predefObject.media != "":
            povContent += "\tinterior {\n\t" + obj.predefObject.interior + "\n"
            
            #media
            if obj.predefObject.media != "":
                povContent += "\t\tmedia { " + obj.predefObject.media + " }\n"
            
            povContent += "\t}\n"

        #scale
        if obj.scaleX != 1 or obj.scaleY != 1 or obj.scaleZ != 1:
            povContent += "\tscale <" + str(obj.scaleX) + ", " + str(obj.scaleY) + ", " + str(obj.scaleZ) + ">\n"
        #rotate
        if obj.rotationX != 0 or obj.rotationY != 0 or obj.rotationZ != 0:
            povContent += "\trotate <" + str(obj.rotationX) + ", " + str(obj.rotationY) + ", " + str(obj.rotationZ) + ">\n"
        #translate
        if obj.translationX != 0 or obj.translationY != 0 or obj.translationZ != 0:
            povContent += "\ttranslate <" + str(obj.translationX) + ", " + str(obj.translationY) + ", " + str(obj.translationZ) + ">\n"

        povContent += "}\n\n"

        if platform.system() == "Windows":
            povContent.replace("\n", "\r\n")

        return povContent

    def createIniContent(self):
        self.settingsToCSV()
        
        self.iniContent = ""
        self.iniContent += self.csv + "\n"
        self.iniContent += "Input_File_Name='" + self.renderSettings.povName + "'\n"
        self.iniContent += "Width=" + str(self.renderSettings.width) + "\n"
        self.iniContent += "Height=" + str(self.renderSettings.height) + "\n"
        self.iniContent += "Fatal_File='" + self.renderSettings.errorName + "'\n"

    def onCancel(self): #called if "Cancel" button is pressed
        self.result = "Canceled"
        self.close()
        App.Console.PrintMessage("\n\nCanceled\n\n")

    def onOk(self): #called if "OK" button is pressed
        self.result = "OK"
        self.close()
        self.saveActiveDocName()

        iniPath = self.pathLineEdit.text()
        directory = os.path.dirname(iniPath) + os.sep
        projectName = os.path.basename(iniPath)[:-4]

        #create renderSettings object
        self.renderSettings = RenderSettings(directory, projectName,
                                             self.imageWidth.value(),
                                             self.imageHeight.value(),
                                             self.expBg.isChecked(),
                                             self.expLight.isChecked(),
                                             self.repRot.isChecked(),
                                             self.expFcView.isChecked())

        self.createTexIncContent()
        self.writeTextureInc()

        self.createIniContent()
        self.writeIni()

        exporter = ExportToPovRay(self.renderSettings)

class Predefined:
    def __init__(self, identifier, material, texture, pigment, finish, normal, interior, media, inc, treeItem):
        self.identifier = identifier
        self.material = material
        self.texture = texture
        self.pigment = pigment
        self.finish = finish
        self.normal = normal
        self.interior = interior
        self.media = media
        self.inc = inc
        self.treeItem = treeItem

    def getHash(self):
        #parentCategorie = self.treeItem.parent().text(0)
        predefName = self.treeItem.text(0)

        stgStr = str(self.identifier) + str(self.material) + str(self.texture) + str(self.pigment) + str(self.finish) + str(self.normal) + str(self.interior) + str(self.media) + str(self.inc)
        hashStr = hashlib.md5(stgStr.encode("UTF-8")).hexdigest()[:4]

        #return parentCategorie + "/" + predefName + hashStr
        return predefName + hashStr

class ListObject:
    def __init__(self, fcObj, listItem, predefObject, scaleX, scaleY, scaleZ, rotationX, rotationY, rotationZ, translationX, translationY, translationZ):
        self.fcObj = fcObj
        self.label = stringCorrection(fcObj.Label)

        self.scaleX = scaleX
        self.scaleY = scaleY
        self.scaleZ = scaleZ

        self.rotationX = rotationX
        self.rotationY = rotationY
        self.rotationZ = rotationZ

        self.translationX = translationX
        self.translationY = translationY
        self.translationZ = translationZ

        self.listItem = listItem
        self.predefObject = predefObject

class RenderSettings:
    def __init__(self, directory, projectName, width, height, expBg, expLight, repRot, expFcView):
        self.projectName = projectName
        self.directory = directory

        self.iniName = self.projectName + ".ini"
        self.iniPath = self.directory + self.iniName
        self.povName = self.projectName + ".pov"
        self.povPath = self.directory + self.povName
        
        self.incName = self.projectName + ".inc"
        self.incPath = self.directory + self.incName
        self.meshName = self.projectName + "_meshes.inc"
        self.meshPath = self.directory + self.meshName
        self.errorName = self.projectName + "_FatalError.out"
        self.errorPath = self.directory + self.errorName
        self.fcViewName = self.projectName + "_FC-View.png"
        self.fcViewPath = self.directory + self.fcViewName
        self.texIncName = self.projectName + "_textures.inc"
        self.texIncPath = self.directory + self.texIncName

        #get all output options
        self.width = width
        self.height = height

        self.expBg = expBg
        self.expLight = expLight
        self.repRot = repRot
        self.expFcView = expFcView

def main(): #the main function
    #version = float(App.Version()[1])
    #if version < 17:
        #errText = "You're using an old FreeCAD version.\n"
        #errText += "The macro doesn't work with version 0.16 or older.\n"
        #errText += "\nPlease update to 0.17 or newer."
        #showError(errText, "FreeCAD version too old")
        #return -1
    
    if App.ActiveDocument == None:
        App.Console.PrintWarning("No document opened\n")
        return -1
    else:
        dialog = GUI()
        dialog.exec_()
main()
