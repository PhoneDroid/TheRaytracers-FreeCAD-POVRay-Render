# -*- coding: utf-8 -*-

from FreeCAD import Base
from pivy import coin
import os
from PySide import QtCore, QtGui
import math
import MeshPart

def showError(text, title):
    dialog = QtGui.QMessageBox(QtGui.QMessageBox.Critical, title, text)
    dialog.setWindowModality(QtCore.Qt.ApplicationModal)
    dialog.exec_()

def isAscii(string): #test whether the string is an ASCII string
    return all(ord(c) < 128 for c in string)

class ExportToPovRay:
    """Export the FreeCAD model to POVray"""
    def __init__(self, povPath, width, height, expBg, expLight, repRot, expFcView):
        self.doc = FreeCAD.ActiveDocument
        self.objs = self.doc.Objects

        self.povPath = povPath
        self.directory = self.povPath
        while self.directory[-1:] != os.sep:
            self.directory = self.directory[:-1]
        self.povName = self.povPath[len(self.directory):]
        self.fileName = self.povName[:-4]
        self.incName = self.fileName + ".inc"
        self.incPath = self.directory + self.incName
        self.meshName = self.fileName + "_meshes.inc"
        self.meshPath = self.directory + self.meshName
        self.errorName = self.fileName + "_FatalError.out"
        self.errorPath = self.directory + self.errorName
        self.fcViewName = self.fileName + "_FC-View.png"
        self.fcViewPath = self.directory + self.fcViewName

        self.width = width
        self.height = height

        self.expBg = expBg
        self.expLight = expLight
        self.repRot = repRot
        self.expFcView = expFcView

        self.DefaultShapeColor =  App.ParamGet("User parameter:BaseApp/Preferences/View").GetUnsigned('DefaultShapeColor') #default color of shapes in FreeCAD (default rgb(0.8, 0.8, 0.8))
        self.CamOri = Gui.ActiveDocument.ActiveView.getCameraOrientation()
        self.CamType = Gui.ActiveDocument.ActiveView.getCameraType()
        self.CamPos = Gui.ActiveDocument.ActiveView.viewPosition()
        self.CamNode = Gui.ActiveDocument.ActiveView.getCameraNode()
        self.EulerCam = Gui.ActiveDocument.ActiveView.getCameraOrientation().toEuler()

        #user inc file
        self.userInc = False

        if self.povPath != -1 and self.povPath != "" and self.povPath != " ": #is there a pov file
            try: #try to open pov file
                file = open(self.povPath, "w+") #really "w+"?
                file.close()
                App.Console.PrintMessage("\n\nPath to *.pov File: " + self.povPath + "\n")
            except:
                App.Console.PrintError("Can't open the pov file\n\n")
                return -1

            try: #try to open inc file
                file = open(self.incPath, "r")
                self.incContent = file.read()
                file.close()

                App.Console.PrintMessage("Include file found: " + self.incPath + "\n")
                self.incContent = self.delComments(self.incContent)
                self.userInc = True
            except:
                self.incContent = ""
        else:
            App.Console.PrintMessage("\n\nCanceled\n\n")
            return -1

        #get statistics
        objs = FreeCAD.ActiveDocument.Objects
        self.statistics = self.getStatistics(objs)
        App.Console.PrintMessage(self.statistics[0])

        #clear old mesh file
        try:
            file = open(self.meshPath)
            file.close()
            self.meshFile = open(self.meshPath, "w")
            if self.statistics[1] == False:
                self.meshFile.close()
        except:
            if self.statistics[1]:
                self.meshFile = open(self.meshPath, "w")


        self.startExport()

    def startExport(self): #start the export to POVray
        firstLayer = []

        #repair rotation
        if self.repRot:
            self.repairRot(self.objs)

        #export FreeCAD view
        if self.expFcView:
            self.exportFcView()

        #get the first layer and check visibility of parent objects
        for obj in self.objs:
            if obj.InList == [] or (len(obj.InList) == 1 and (obj.InList[0].Name == "Clone" or obj.InList[0].Name[:-3] == "Clone")): #no parents
                guiObject = obj.ViewObject
                if guiObject.Visibility:
                    firstLayer.append(obj)

        finalPovCode = "#version 3.6; // 3.7\nglobal_settings{assumed_gamma 1.0}\n#default{ finish{ ambient 0.2 diffuse 0.9 }}\n"

        finalPovCode += "#default{pigment{rgb " + self.uintColorToRGB(self.DefaultShapeColor) + "}}\n"

        finalPovCode += "//------------------------------------------\n"
        finalPovCode += "#include \"colors.inc\"\n#include \"textures.inc\"\n"

        if self.statistics[1]:
            finalPovCode += "#include \"" + self.meshName + "\"\n"

        finalPovCode += "\n//------------------------------------------\n"
        finalPovCode += "// camera ----------------------------------\n"
        finalPovCode += self.getCam()

        if self.expLight:
            finalPovCode += "\n// sun -------------------------------------\n"
            finalPovCode += self.getLight()

        if self.expBg:
            finalPovCode += "\n// background ------------------------------\n"
            finalPovCode += self.getBackground()

        #emission rgb <0.8,0.8,1>
        finalPovCode += "\n//------------------------------------------\n"

        if self.userInc:
            finalPovCode += "\n#include \"" + self.incName + "\"\n\n"

        finalPovCode += "// objects in scene ------------------------\n"

        #create the povray code
        for obj in firstLayer:
            finalPovCode += self.createPovrayCode(obj)
        if self.statistics[1]:
            self.meshFile.close()

        self.writeFile(finalPovCode)
        self.openPovRay()


    def createPovrayCode(self, fcObj, expPlacement = True, expPigment = True, expClose = True, expLabel = True, expMeshDef = True): #returns the povray code for the object
        if expLabel:
            povCode = "\n//----- " + self.stringCorrection(fcObj.Label) + " -----" #add the name of the object
        else:
            povCode = ""

        if fcObj.TypeId == "Part::Box": #Box
            povBox = "\nbox{ <0,0,0>, <" + str(float(fcObj.Length)) + ", " + str(float(fcObj.Width)) + ", " + str(float(fcObj.Height)) + ">"
            povCode += povBox

        elif fcObj.TypeId == "Part::Sphere": # Sphere
            radius = fcObj.Radius.getValueAs("mm")

            povSphere = "\nsphere { <0, 0, 0> " + str(radius)

            povCode += povSphere

        elif fcObj.TypeId == "Part::Ellipsoid": # Ellipsoid
            r1 = fcObj.Radius1.getValueAs("mm").Value
            r2 = fcObj.Radius2.getValueAs("mm").Value
            r3 = fcObj.Radius3.getValueAs("mm").Value

            povSphere = "\nsphere { <0, 0, 0> 1\n"

            povSphere += "\tscale <" + str(r2) + ", " + str(r3) + ", " + str(r1) + ">"

            povCode += povSphere

        elif fcObj.TypeId == "Part::Cone": #Cone
            r1 = fcObj.Radius1.getValueAs("mm").Value
            c1 = "<0, 0, 0>"
            r2 = fcObj.Radius2.getValueAs("mm").Value
            c2 = "<0, 0, " + str(fcObj.Height.getValueAs("mm").Value) + ">"

            povCone = "\ncone { "
            povCone += c1 + ", " + str(r1) + "\n    "
            povCone += c2 + ", " + str(r2)

            povCode += povCone

        elif fcObj.TypeId == "Part::Cylinder": #Cylinder
            r = fcObj.Radius.getValueAs("mm").Value
            baseP = "<0, 0, 0>"
            CapP = "<0, 0, " + str(fcObj.Height.getValueAs("mm").Value) + ">"

            povCylinder = "\ncylinder { "
            povCylinder += baseP + ", " + CapP + ", " + str(r)

            povCode += povCylinder

        elif fcObj.TypeId == "Part::Torus": #Torus
            r1 = fcObj.Radius1.getValueAs("mm").Value
            r2 = fcObj.Radius2.getValueAs("mm").Value

            povTorus = "\ntorus { "
            povTorus += str(r1) + ", " + str(r2)

            povCode += povTorus

        elif fcObj.TypeId == "Part::Plane": #Plane
            width = fcObj.Width.getValueAs("mm").Value
            length = fcObj.Length.getValueAs("mm").Value

            povPlane = "\npolygon { "
            povPlane += "5, <0, 0>, <" + str(length) + ", 0>, <" + str(length) + ", " + str(width) + ">, <0, " + str(width) + ">, <0, 0>"

            povCode += povPlane

        elif fcObj.TypeId == "Part::Cut":  #Cut
            childs = fcObj.OutList
            povCut = "\ndifference {\n"
            for child in childs:
                childCode = self.createPovrayCode(child, expPlacement, expPigment, True, expLabel, expMeshDef) #call createPovrayCode for the child
                povCut += childCode.replace("\n", "\n\t") #add the indents

            povCode += povCut

        elif fcObj.TypeId == "Part::MultiFuse" or fcObj.TypeId == "Part::Fuse": #Fusion
            childs = fcObj.OutList
            povFusion = "\nunion {\n"
            for child in childs:
                childCode = self.createPovrayCode(child, expPlacement, expPigment, True, expLabel, expMeshDef) #call createPovrayCode for the child
                povFusion += childCode.replace("\n", "\n\t") #add the indents

            povCode += povFusion

        elif fcObj.TypeId == "Part::MultiCommon" or fcObj.TypeId == "Part::Common": #Common
            childs = fcObj.OutList
            povCommon = "\nintersection {\n"
            for child in childs:
                childCode = self.createPovrayCode(child, expPlacement, expPigment, True, expLabel, expMeshDef) #call createPovrayCode for the child
                povCommon += childCode.replace("\n", "\n\t") #add the indents

            povCode += povCommon

        elif fcObj.TypeId == "Part::FeaturePython" and (fcObj.Name == "Array" or fcObj.Name[:-3] == "Array"): #Array from Draft workbench
            povArr = ""
            if fcObj.ArrayType == "polar":
                childs = fcObj.OutList
                for child in childs:
                    center = "<" + str(fcObj.Center.x) + ", " + str(fcObj.Center.y) + ", " + str(fcObj.Center.z) + ">"
                    axisX = fcObj.Axis.x
                    axisY = fcObj.Axis.y
                    axisZ = fcObj.Axis.z
                    highestAxis = max(axisX, axisY, axisZ) #get highest value
                    axisX /= highestAxis
                    axisY /= highestAxis
                    axisZ /= highestAxis


                    axis = "<" + str(axisX) + ", " + str(axisY) + ", " + str(axisZ) + ">"
                    intervalAxis = "<" + str(fcObj.IntervalAxis.x) + ", " + str(fcObj.IntervalAxis.y) + ", " + str(fcObj.IntervalAxis.z) + ">"
                    number = fcObj.NumberPolar
                    angle = fcObj.Angle.getValueAs("deg").Value

                    declareName = self.stringCorrection(child.Label.capitalize()) + "_" + child.Name
                    povArr += "\n#declare " + declareName + " = "
                    childCode = self.createPovrayCode(child, expPlacement, expPigment, True, expLabel, expMeshDef) #call createPovrayCode for the child
                    povArr += childCode

                    povArr += "\n#declare i = 0;\n"
                    povArr += "#declare endNo = " + str(number) + ";\n"
                    povArr += "#declare axis = " + axis + ";\n"
                    povArr += "#declare arrAngle = " + str(angle) + ";\n"
                    povArr += "#while (i < endNo)\n"
                    povArr += "\tobject { " + declareName + "\n"
                    if fcObj.Center.x != 0 or fcObj.Center.y != 0 or fcObj.Center.z != 0:
                        povArr += "\t\ttranslate -" + center + "\n"

                    povArr += "\t\t#declare rotAngle = i * arrAngle / endNo;\n"
                    povArr += "\t\t#local vX = vaxis_rotate(x, axis, rotAngle);\n"
                    povArr += "\t\t#local vY = vaxis_rotate(y, axis, rotAngle);\n"
                    povArr += "\t\t#local vZ = vaxis_rotate(z, axis, rotAngle);\n"
                    povArr += "\t\ttransform {\n"
                    povArr += "\t\t\tmatrix <vX.x, vX.y, vX.z, vY.x, vY.y, vY.z, vZ.x, vZ.y, vZ.z, 0, 0, 0>\n"
                    povArr += "\t\t}\n"

                    if fcObj.Center.x != 0 or fcObj.Center.y != 0 or fcObj.Center.z != 0:
                        povArr += "\t\ttranslate " + center + "\n"

                    if expPlacement:
                        rotation = self.getRot(fcObj)
                        if rotation != "": #test if the object is rotated
                            povArr += "        " + rotation + "\n"

                    if fcObj.IntervalAxis.x != 0 or fcObj.IntervalAxis.y != 0 or fcObj.IntervalAxis.z != 0:
                        povArr += "\t\ttranslate " + intervalAxis + " * i\n"

                    if expPlacement:
                        translation = self.getTranslation(fcObj)
                        if translation != "": #test if the object is translated
                            povArr += "\t" + translation + "\n"

                    if expPigment:
                        pigment = self.getPigment(fcObj)
                        if pigment != "": #test if the object has the standard pigment
                            povArr += "\t" + pigment + "\n"

                    povArr += "    }\n\t#declare i = i + 1;\n"
                    povArr += "#end\n"

                povCode += povArr

            elif fcObj.ArrayType == "ortho":
                childs = fcObj.OutList
                for child in childs:
                    intervalX = "<" + str(fcObj.IntervalX.x) + ", " + str(fcObj.IntervalX.y) + ", " + str(fcObj.IntervalX.z) + ">"
                    intervalY = "<" + str(fcObj.IntervalY.x) + ", " + str(fcObj.IntervalY.y) + ", " + str(fcObj.IntervalY.z) + ">"
                    intervalZ = "<" + str(fcObj.IntervalZ.x) + ", " + str(fcObj.IntervalZ.y) + ", " + str(fcObj.IntervalZ.z) + ">"

                    numX = fcObj.NumberX
                    if numX == 0:
                        numX = 1

                    numY = fcObj.NumberY
                    if numY == 0:
                        numY = 1

                    numZ = fcObj.NumberZ
                    if numZ == 0:
                        numZ = 1

                    declareName = self.stringCorrection(child.Label.capitalize()) + "_" + child.Name
                    povArr += "\n#declare " + declareName + " = "
                    childCode = self.createPovrayCode(child, expPlacement, expPigment, True, expLabel, expMeshDef) #call createPovrayCode for the child
                    povArr += childCode

                    povArr += "#declare intervalX = " + intervalX + ";\n"
                    povArr += "#declare intervalY = " + intervalY + ";\n"
                    povArr += "#declare intervalZ = " + intervalZ + ";\n\n"

                    povArr += "#declare numX = " + str(numX) + ";\n"
                    povArr += "#declare ix = 0;\n"
                    povArr += "#while (ix < numX)\n"

                    povArr += "\t#declare numY = " + str(numY) + ";\n"
                    povArr += "\t#declare iy = 0;\n"
                    povArr += "\t#while (iy < numY)\n"

                    povArr += "\t\t#declare numZ = " + str(numZ) + ";\n"
                    povArr += "\t\t#declare iz = 0;\n"
                    povArr += "\t\t#while (iz < numZ)\n"

                    povArr += "\t\t\tobject { " + declareName + "\n"
                    povArr += "\t\t\t\ttranslate intervalX * ix\n"
                    povArr += "\t\t\t\ttranslate intervalY * iy\n"
                    povArr += "\t\t\t\ttranslate intervalZ * iz\n"

                    if expPlacement:
                        translation = self.getTranslation(fcObj)
                        if translation != "": #test if the object is translated
                            povArr += "\t\t\t\t" + translation + "\n"

                        rotation = self.getRot(fcObj)
                        if rotation != "": #test if the object is rotated
                            povArr += "\t\t\t\t" + rotation + "\n"

                    if expPigment:
                        pigment = self.getPigment(fcObj)
                        if pigment != "": #test if the object has the standard pigment
                            povArr += "\t\t\t\t" + pigment + "\n"

                    povArr += "\t\t\t}\n"

                    povArr += "\t\t\t#declare iz = iz + 1;\n"
                    povArr += "\t\t#end\n"
                    povArr += "\t\t#declare iy = iy + 1;\n"
                    povArr += "\t#end\n"
                    povArr += "\t#declare ix = ix + 1;\n"
                    povArr += "#end\n"

                    povCode += povArr

            return povCode

        elif fcObj.TypeId == "Part::FeaturePython" and (fcObj.Name == "Clone" or fcObj.Name[:-3] == "Clone"): #Clone from Draft workbench
            povClone = ""
            childs = fcObj.OutList
            for child in childs:
                if fcObj.ViewObject.Visibility:
                    povClone += self.createPovrayCode(child, False, False, False, False, False)
                else:
                    povClone += self.createPovrayCode(child, False, False, False, False, True)

            povCode += povClone

        elif fcObj.TypeId == "App::DocumentObjectGroup": #Group
            childs = fcObj.OutList
            for child in childs:
                childCode = self.createPovrayCode(child, expPlacement, expPigment, True, expLabel, expMeshDef) #call createPovrayCode for the child
                povCode += childCode
            return povCode

        elif fcObj.TypeId == "PartDesign::Body": #Body from PartDesign
            if not self.isBodySupported(fcObj):
                povCode += self.createMesh(fcObj, expPlacement, expPigment, expClose, expMeshDef)
                return povCode #return because the mesh may not translated and rotated

            povBody = "\nunion {\n"
            if fcObj.Tip != None:
                povBody += self.createPovrayCode(fcObj.Tip).replace("\n", "\n\t") #add chld code and indents
                povCode += povBody
            else:
                return ""

        elif fcObj.TypeId == "PartDesign::Pad" or fcObj.TypeId == "PartDesign::Pocket": #Pad or Pocket from PartDesign
            spline = self.sketchToBezier(fcObj.Profile[0])

            startHeight = 0;
            if fcObj.TypeId == "PartDesign::Pocket":
                startHeight = -0.0001
            endHeight = fcObj.Length.getValueAs("mm").Value
            if fcObj.Midplane:
                endHeight /= 2
                startHeight = -endHeight
            startHeight += fcObj.Offset.getValueAs("mm").Value
            endHeight += fcObj.Offset.getValueAs("mm").Value
            if not fcObj.Reversed:
                startHeight *= -1
                endHeight *= -1
            if fcObj.TypeId == "PartDesign::Pocket":
                startHeight *= -1
                endHeight *= -1

            povPad = ""
            try:
                if fcObj.TypeId == "PartDesign::Pocket":
                    povPad += "\ndifference {\n"
                else:
                    povPad += "\nunion {\n"
            except:
                povPad += "\nunion {\n"

            if fcObj.BaseFeature != None:
                povBase = self.createPovrayCode(fcObj.BaseFeature)
                povPad += povBase.replace("\n", "\n\t") #add the indents

            povPad += "\n\tprism {\n"
            povPad += "\t\tbezier_spline\n"
            povPad += "\t\t" + str(startHeight) + ", " + str(endHeight) + ", " + str(spline[1])
            povPad += spline[0].replace("\n", "\n\t\t") + "\n" #add the indents

            if expPlacement:
                rotation = self.getRot(fcObj.Profile[0])
                if rotation != "": #test if the object is rotated
                    povPad += "\t\t" + rotation + "\n"

                translation = self.getTranslation(fcObj.Profile[0])
                if translation != "": #test if the object is translated
                    povPad += "\t\t" + translation + "\n"

            povPad += "\n\t}\n"

            povPad += "\n}\n"

            povCode += povPad
            return povCode

        else: #not a supported object
            povCode += self.createMesh(fcObj, expPlacement, expPigment, expClose, expMeshDef)
            return povCode #return because the mesh may not translated and rotated

        povCode += "\n"

        if expPlacement:
            rotation = self.getRot(fcObj)
            if rotation != "": #test if the object is rotated
                povCode += "\t" + rotation + "\n"

            translation = self.getTranslation(fcObj)
            if translation != "": #test if the object is translated
                povCode += "\t" + translation + "\n"

        if expPigment:
            pigment = self.getPigment(fcObj)
            if pigment != "": #test if the object has the standard pigment
                povCode += pigment.replace("\n", "\n\t") + "\n"

        if expClose:
            povCode += "}\n"

        return povCode

    def sketchToBezier(self, sketch): #create pov bezier_spline from sketch
        povSpline = "\n"

        unsortedLines = sketch.Geometry

        #delete construction geometry
        while self.hasLinesConstructive(unsortedLines): #Caution: Very dirty coding!!!
            for line in unsortedLines:
                if line.Construction:
                    del unsortedLines[unsortedLines.index(line)]
                    break

        numOfPoints = len(unsortedLines) * 4

        sortedLines = []

        while unsortedLines: #until the unsortedLines array is empty
            sortedLines.append(unsortedLines[0])
            startLine = unsortedLines[0]
            del unsortedLines[0]

            while not self.isSamePoint(startLine.StartPoint, sortedLines[len(sortedLines) - 1].EndPoint):
                # handling of -1 missing
                nextLineI = self.getNextLine(unsortedLines, sortedLines[len(sortedLines) - 1])

                #change direction
                if self.isSamePoint(sortedLines[len(sortedLines) - 1].EndPoint, unsortedLines[nextLineI].EndPoint):
                    unsortedLines[nextLineI].reverse()

                sortedLines.append(unsortedLines[nextLineI])
                del unsortedLines[nextLineI]

        #create povSpline
        for line in sortedLines:
            povSpline += "<" + str(line.StartPoint.x) + ", " + str(line.StartPoint.y) + ">, "
            povSpline += "<" + str(line.StartPoint.x) + ", " + str(line.StartPoint.y) + ">, "
            povSpline += "<" + str(line.EndPoint.x) + ", " + str(line.EndPoint.y) + ">, "
            povSpline += "<" + str(line.EndPoint.x) + ", " + str(line.EndPoint.y) + ">\n"

        return [povSpline, numOfPoints]

    def getNextLine(self, lines, lastLine): #returns index
        i = 0
        for line in lines:
            if self.isSamePoint(line.EndPoint, lastLine.EndPoint) or self.isSamePoint(line.StartPoint, lastLine.EndPoint):
                return i
            i += 1
        return -1

    def isSamePoint(self, point1, point2): #are two points equal
        if round(point1.x, 3) == round(point2.x, 3) and round(point1.y, 3) == round(point2.y, 3) and round(point1.z, 3) == round(point2.z, 3):
            return True
        return False

    def hasLinesConstructive(self, lines): #are constructive lines in lines array
        constructive = False
        for line in lines:
            if line.Construction:
                return True
        return False

    def isBodySupported(self, body): #is a body full supported
        supportedTypeIds = ["App::Origin",
                            "App::Line",
                            "App::Plane",
                            "Sketcher::SketchObject",
                            "PartDesign::Pad",
                            "PartDesign::Pocket",
                            "PartDesign::Point",
                            "PartDesign::Line",
                            "PartDesign::Plane"]

        childs = body.OutListRecursive

        #are objects supported
        for obj in childs:
            if not obj.TypeId in supportedTypeIds:
                return False

        #get sketches
        sketches = []
        for obj in childs:
            if obj.TypeId == "Sketcher::SketchObject":
                sketches.append(obj)

        #test sketches
        supportedGeometryTypes = [Part.LineSegment]
        for sketch in sketches:
            for line in sketch.Geometry:
                if not type(line) in supportedGeometryTypes and not line.Construction:
                    return False

        supportedTypes = ["Length"]
        #get pads and pockets
        padsPockets = []
        for obj in childs:
            if obj.TypeId == "PartDesign::Pad" or obj.TypeId == "PartDesign::Pocket":
                padsPockets.append(obj)

        #test types
        for obj in padsPockets:
            if not obj.Type in supportedTypes:
                return False

        return True

    def createMesh(self, fcObj, expPlacement = True, expPigment = True, expClose = True, expMeshDef = True): #create pov mesh from object
        povCode = ""

        isSolid = self.isSolid(fcObj)
        if isSolid != "mesh" and isSolid == False:
            return ""

        if expMeshDef:
            mesh = 0

            if fcObj.isDerivedFrom("Mesh::Feature"): #is fcObj a mesh
                mesh = fcObj.Mesh
            else:
                distanceCam = abs(fcObj.Shape.BoundBox.Center.distanceToPoint(Gui.ActiveDocument.ActiveView.viewPosition().Base) - fcObj.Shape.BoundBox.DiagonalLength / 2)
                pictureSize = (self.width + self.height) / 2
                angularDeflection = (distanceCam / pictureSize) * 2.5
                mesh = MeshPart.meshFromShape(Shape = fcObj.Shape, LinearDeflection = 0.1, AngularDeflection = angularDeflection, Relative = False)

            if not mesh:
                return ""

            #create mesh2 object
            povMesh = "#declare " + self.stringCorrection(fcObj.Label) + "_mesh ="
            povMesh += "\nmesh2 {\n\tvertex_vectors {\n"

            #create vertex_vectors
            numOfVertex = len(mesh.Topology[0])
            povMesh += "\t\t" + str(numOfVertex)

            for point in mesh.Topology[0]:
                povMesh += ",\n\t\t<" + str(point.x) + ", " + str(point.y) + ", " + str(point.z) + ">"
            povMesh += "\n\t}\n\n"

            #create face_indices
            povMesh += "\tface_indices {\n"
            numOfTriangles = len(mesh.Topology[1])
            povMesh += "\t\t" + str(numOfTriangles)

            for triangle in mesh.Topology[1]:
                povMesh += ",\n\t\t<" + str(triangle[0]) + ", " + str(triangle[1]) + ", " + str(triangle[2]) + ">"
            povMesh += "\n\t}\n\n"

            #add inside vector
            povMesh += "\tinside_vector <1, 1, 1>\n"

            povMesh += "}\n\n"

            #write mesh in inc file
            self.meshFile.write(povMesh)

        #return pov code
        povCode += "\nobject { " + self.stringCorrection(fcObj.Label) + "_mesh\n"
        pigment = self.getPigment(fcObj)

        if expPlacement == False: #meshes are already translated, so if they shouldnt translated, they translated back
            rotation = self.getRot(fcObj)
            if rotation != "": #test if the object is rotated
                povCode += "\t" + rotation + " * (-1)\n"

            translation = self.getTranslation(fcObj)
            if translation != "": #test if the object is translated
                povCode += "\t" + translation + " * (-1)\n"

        if pigment != "": #test if the object has the standard pigment
            povCode += "\t" + pigment + "\n"

        if expClose:
            povCode += "}\n"

        return povCode


    def getStatistics(self, objs): #get statistics about the model the user want to render
        statistics = ""
        noCsgCount = 0
        CsgCount = 0
        ParentCount = 0
        supportedTypeIds = ["Part::Sphere",
                            "Part::Box",
                            "Part::Torus",
                            "Part::Cylinder",
                            "Part::Cone",
                            "Part::Ellipsoid",
                            "Part::Plane", "Part::Cut",
                            "Part::MultiFuse", "Part::Fuse",
                            "Part::MultiCommon", "Part::Common",
                            "PartDesign::Body"
                            "PartDesign::Pad",
                            "PartDesign::Pocket",
                            "Sketcher::SketchObject",
                            "App::DocumentObjectGroup"]
        supportedNames = ["Array", "Clone"]
        for obj in objs:
            if not obj.TypeId in supportedTypeIds and not obj.Name in supportedNames and not obj.Name[:-3] in supportedNames:
                noCsgCount = noCsgCount + 1
            else:
                CsgCount = CsgCount + 1
            if obj.InList == []:
                ParentCount = ParentCount + 1
        statistics += str(ParentCount) + " parent objects found in highest layer\n"
        statistics += "containing totally " + str(CsgCount + noCsgCount) + " objects\n"
        if noCsgCount != 0:
            statistics += "Your model contains " + str(noCsgCount) + " objects which aren't from the part workbench.\n"
        return [statistics, noCsgCount]

    def getLight(self): #get the FreeCAD light
        povLight = ""

        #povLight += "light_source{<1500,3000,-2500> color rgb<1,1,1>}\n"
        povLight += "light_source { <" + str(self.CamPos.Base.x) + ", " + str(self.CamPos.Base.y) + ", " + str(self.CamPos.Base.z) + "> color rgb<0.5, 0.5, 0.5> }\n"

        return povLight

    def getBackground(self): #get the FreeCAD background
        bgColor1 = App.ParamGet("User parameter:BaseApp/Preferences/View").GetUnsigned('BackgroundColor')
        bgColor2 = App.ParamGet("User parameter:BaseApp/Preferences/View").GetUnsigned('BackgroundColor2')
        bgColor3 = App.ParamGet("User parameter:BaseApp/Preferences/View").GetUnsigned('BackgroundColor3')
        bgColor4 = App.ParamGet("User parameter:BaseApp/Preferences/View").GetUnsigned('BackgroundColor4')
        ViewDir = Gui.ActiveDocument.ActiveView.getViewDirection()

        AspectRatio = self.width / float(self.height)
        povBg = ""

        if self.CamType == "Orthographic":
            if AspectRatio >= 1:
                up = self.CamNode.height.getValue()
                right = up * AspectRatio
            else:
                right = self.CamNode.height.getValue()
                up = right/AspectRatio
            povBg += "\npolygon {\n"
            povBg += "\t5, <" + str(-right/2) + ", " + str(-up/2) + ">, <" + str(-right/2) + ", "
            povBg += str(up/2) + ">, <" + str(right/2) + ", " + str(up/2) + ">, <" + str(right/2) + ", " + str(-up/2)
            povBg += ">, <" + str(-right/2) + ", " + str(-up/2) + ">\n"
            povBg += "\tpigment {"
            if App.ParamGet("User parameter:BaseApp/Preferences/View").GetBool('Simple'):
                povBg += " color rgb" + self.uintColorToRGB(bgColor1) + "}\n"
            elif App.ParamGet("User parameter:BaseApp/Preferences/View").GetBool('Gradient'):
                povBg += "\n\t\tgradient y\n"
                povBg += "\t\tcolor_map {\n"
                povBg += "\t\t\t[ 0.00  color rgb" + self.uintColorToRGB(bgColor3) +" ]\n"
                povBg += "\t\t\t[ 0.05  color rgb" + self.uintColorToRGB(bgColor3) +" ]\n"
                if App.ParamGet("User parameter:BaseApp/Preferences/View").GetBool('UseBackgroundColorMid'):
                    povBg += "\t\t\t[ 0.50  color rgb" + self.uintColorToRGB(bgColor4) +" ]\n"
                povBg += "\t\t\t[ 0.95  color rgb" + self.uintColorToRGB(bgColor2) +" ]\n"
                povBg += "\t\t\t[ 1.00  color rgb" + self.uintColorToRGB(bgColor2) +" ]\n"
                povBg += "\t\t}\n"
                povBg += "\t\tscale<1," + str(up) + ",1>\n"
                povBg += "\t\ttranslate<0," + str(-up/2) + ",0>\n"
                povBg += "\t}\n"
            #color rgb<0,0,1>}\n"
            povBg += "\tfinish{ambient 1 diffuse 0}\n"
            povBg += "\trotate<" + str(self.EulerCam[2]) + ", " + str(self.EulerCam[1]) + ", " + str(self.EulerCam[0]) + ">\n"
            povBg += "\ttranslate <" + str(self.CamPos.Base.x) + ", " + str(self.CamPos.Base.y) + ", " + str(self.CamPos.Base.z) + ">\n"
            povBg += "\ttranslate <" + str(ViewDir[0]*1000) + ", " + str(ViewDir[1]*1000) + ", " + str(ViewDir[2]*1000) + ">\n"
            povBg += "}\n"

        povBg += "sky_sphere {\n\tpigment {\n"
        if App.ParamGet("User parameter:BaseApp/Preferences/View").GetBool('Simple'):
            povBg += " color rgb" + self.uintColorToRGB(bgColor1)

        elif App.ParamGet("User parameter:BaseApp/Preferences/View").GetBool('Gradient'):
            povBg += "\t\tgradient z\n"
            povBg += "\t\tcolor_map {\n"
            povBg += "\t\t\t[ 0.00  color rgb" + self.uintColorToRGB(bgColor3) +" ]\n"
            povBg += "\t\t\t[ 0.30  color rgb" + self.uintColorToRGB(bgColor3) +" ]\n"
            if App.ParamGet("User parameter:BaseApp/Preferences/View").GetBool('UseBackgroundColorMid'):
                povBg += "\t\t\t[ 0.50  color rgb" + self.uintColorToRGB(bgColor4) +" ]\n"
            povBg += "\t\t\t[ 0.70  color rgb" + self.uintColorToRGB(bgColor2) +" ]\n"
            povBg += "\t\t\t[ 1.00  color rgb" + self.uintColorToRGB(bgColor2) +" ]\n"
            povBg += "\t\t}\n"
            povBg += "\t\tscale 2\n"
            povBg += "\t\ttranslate -1\n"
            povBg += "\t\trotate<" + str(self.EulerCam[2]-90) + ", " + str(self.EulerCam[1]) + ", " + str(self.EulerCam[0]) + ">\n"
        povBg += "\t}\n}\n"

        return povBg

    def getCam(self): #get the FreeCAD camera
        AspectRatio = self.width / float(self.height)

        PovCam = ""
        CamComment = ""
        incCamera = False

        PovCamType = ""
        PovCamAngle = ""
        PovCamUp = ""
        PovCamRight = ""

        if self.CamType == "Perspective":
            PovCamUp = "< 0, 0, 1>"
            PovCamRight = "<" + "{0:1.2f}".format(AspectRatio) + ", 0, 0>"

            if AspectRatio <= 1:
                CamAngle = 45
            else:
                CamAngle = math.degrees(math.atan2(AspectRatio/2,1.2071067812))*2
            PovCamAngle = "\tangle {0:1.2f}".format(CamAngle) + "\n"
            CamComment += "Perspective Camera\n"

        elif self.CamType == "Orthographic":
            if AspectRatio >= 1:
                up = up = self.CamNode.height.getValue()
                right = up*AspectRatio
            else:
                right = self.CamNode.height.getValue()
                up = right/AspectRatio
            PovCamType = "\torthographic\n"
            PovCamUp = "< 0, 0, " + "{0:1.2f}".format(up) + ">"
            PovCamRight = "<" + "{0:1.2f}".format(right) +", 0, 0>"
            CamComment += "Orthographic camera\n"

        else:
            CamComment += "Unknown camera type - rudimentary camera statement will be used\n"

        PovCam += "#declare CamUp = " + PovCamUp + ";\n"
        PovCam += "#declare CamRight = " + PovCamRight + ";\n"
        PovCam += "#declare CamRotation = <" + str(self.EulerCam[2]-90) + ", " + str(self.EulerCam[1]) + ", " + str(self.EulerCam[0]) + ">;\n"
        PovCam += "#declare CamPosition = <" + str(self.CamPos.Base.x) + ", " + str(self.CamPos.Base.y) + ", " + str(self.CamPos.Base.z) + ">;\n"

        if self.incContent.find("camera") != -1:
            incCamera = True
            PovCam += "/*"

        PovCam += "camera {\n"
        PovCam += PovCamType
        PovCam += "\tlocation <0, 0, 0>\n"
        PovCam += "\tdirection < 0, 1, 0>\n"
        PovCam += "\tup CamUp\n"
        PovCam += "\tright CamRight\n"
        PovCam += "\trotate CamRotation\n"
        PovCam += "\ttranslate CamPosition\n"
        PovCam += PovCamAngle
        PovCam += "}\n"
        if incCamera:
            PovCam += "*/\n"
            CamComment = "User defined camera found - FreeCAD camera will be commented out in *.pov file\n"

        App.Console.PrintMessage(CamComment)

        return PovCam


    def getTranslation(self, fcObj): #get the translation of an object
        translation = ""
        x = fcObj.Placement.Base.x #get the position in every axis
        y = fcObj.Placement.Base.y
        z = fcObj.Placement.Base.z
        if x != 0 or y != 0 or z != 0: #test whether the position is 0,0,0
            translation += "translate <" + str(x) + ", " + str(y) + ", " + str(z) + ">" #create translation vector

        return translation

    def getRot(self, fcObj): #get the rotation of an object
        rotate = ""
        eulerRot = fcObj.Placement.Rotation.toEuler() #convert the rotation to euler angles
        x = eulerRot[2] #get rotation in every axis
        y = eulerRot[1]
        z = eulerRot[0]

        if fcObj.TypeId == "Part::Torus": #if fcObj is a torus it is necessary to rotate it in x axis
            x += 90
        elif fcObj.TypeId == "Sketcher::SketchObject":
            x -= 90

        if x != 0 or y != 0 or z != 0:
            rotate = "rotate <" + str(x) + ", " + str(y)+ ", "  + str(z) + ">" #create roation vector

        return rotate

    def getPigment(self, fcObj): #get the pigment of an object
        appObject = fcObj.ViewObject
        material = ""
        pigment = ""
        transparency = ""
        finish = ""
        ambient = ""
        emission = ""
        phong = ""
        if appObject.Transparency != 0:
            transparency += " transmit " + str(appObject.Transparency / float(100))
        ShapeColorRGB = "<{0:1.3f}, {1:1.3f}, {2:1.3f}>".format(appObject.ShapeColor[0],appObject.ShapeColor[1],appObject.ShapeColor[2])
        if transparency != "" or ShapeColorRGB != self.uintColorToRGB(self.DefaultShapeColor):
            pigment += "\tpigment { color rgb " + ShapeColorRGB + transparency + " }\n"
        material += pigment
        if appObject.ShapeMaterial.AmbientColor != (0.20000000298023224,0.20000000298023224,0.20000000298023224,0):
            ambient += "ambient rgb<"
            ambient += "{0:1.3f}, {1:1.3f}, {2:1.3f}".format(appObject.ShapeMaterial.AmbientColor[0],appObject.ShapeMaterial.AmbientColor[1],appObject.ShapeMaterial.AmbientColor[2])
            ambient += ">"
        if appObject.ShapeMaterial.EmissiveColor != (0,0,0,0):
            emission += "emission rgb<"
            emission += "{0:1.3f}, {1:1.3f}, {2:1.3f}".format(appObject.ShapeMaterial.EmissiveColor[0],appObject.ShapeMaterial.EmissiveColor[1],appObject.ShapeMaterial.EmissiveColor[2])
            emission += ">"
        if appObject.ShapeMaterial.SpecularColor != (0,0,0,0):
            phong += "phong "
            phong += "{0:1.2f}".format((appObject.ShapeMaterial.SpecularColor[0]+appObject.ShapeMaterial.SpecularColor[1]+appObject.ShapeMaterial.SpecularColor[2])/3)
            phong += " phong_size "
            phong += str(appObject.ShapeMaterial.Shininess * 50)
            phong += " "
        if ambient != "" or emission != "" or  phong != "":
            finish = "finish {"
            finish += "\n\t" + ambient
            finish += "\n\t" + emission
            finish += "\n\t" + phong
            finish += "\n}\n"
        material += finish
        if self.incContent.find("#declare " + self.stringCorrection(fcObj.Label) + "_material") != -1:
            material = "\nmaterial {" + self.stringCorrection(fcObj.Label) + "_material}\n"
        return material


    def writeFile(self, povText): #write the final pov file
        #povText: the code for POVray
        try:
            file = open(self.povPath, "w+") #open file (Really "w+"?)
            file.write(povText) #write code
            file.close() #close file
        except:
            return -1

    def openPovRay(self): #start POVray
        terminalInput = "cd " + str(self.directory) + " && povray " + str(self.povName) + " +P Width=" + str(self.width) + " Height=" + str(self.height) + " Fatal_File=" + self.errorName #create the string to start POVray
        os.system(terminalInput) #put terminalInput to the console
        self.checkErrFile()

    def checkErrFile(self): #check error file for errors
        inPovFile = False
        #open error file
        file = open(self.errorPath, "r")
        #read error file
        error = file.read()
        file.close()
        #is there any content in the file
        if error != "": #error occured
            #show error message
            errorText = ""
            errorText += "An error occured while rendering:\n-----------------------------------------\n"
            errorText += error
            errorText += "\n-----------------------------------------\n"
            errorText += "If the error occured in the pov file or the mesh file, please report a bug to us. (See the wiki, link is in the help tab of the dialog)\n\n"
            errorText += "You can see the error message in the error file too."
            showError(errorText, "An error ocurred while rendering")

    def repairRot(self, objs): #repair the rotation of objects (likely a bug in FreeCAD)
        for obj in objs:
            if hasattr(obj, 'Placement'):
                ObjLocation = obj.Placement
                posX = ObjLocation.Base.x
                posY = ObjLocation.Base.y
                posZ = ObjLocation.Base.z
                rotX = ObjLocation.Rotation.Axis[0]
                rotY = ObjLocation.Rotation.Axis[1]
                rotZ = ObjLocation.Rotation.Axis[2]
                rotAngle = math.degrees(ObjLocation.Rotation.Angle)
                obj.Placement = App.Placement(App.Vector(posX, posY, posZ), App.Rotation(App.Vector(rotX, rotY, rotZ), rotAngle), App.Vector(0, 0, 0))

    def exportFcView(self): #export the current FreeCAD view like Tools / Save Picture...
        Gui.ActiveDocument.ActiveView.saveImage(self.fcViewPath, self.width, self.height)

    def isSolid(self, fcObj):
        try:
            if fcObj.Shape.Solids == []:
                return False
            else:
                return True
        except:
            if fcObj.isDerivedFrom("Mesh::Feature") == False:
                return "mesh" #object has no shape property


    def stringCorrection(self, inputString): #change a utf-8 string to an ASCII string
        utfString = inputString.encode("utf8", "replace")     # conversion from ??? to utf8
        uniString = utfString.decode("utf8", "replace")       # conversion from utf8 to unicode
        uniString = uniString.replace(u"Ä", "Ae")             # replacement of german "Umlaute"
        uniString = uniString.replace(u"ä", "ae")
        uniString = uniString.replace(u"Ü", "Ue")
        uniString = uniString.replace(u"ü", "ue")
        uniString = uniString.replace(u"Ö", "Oe")
        uniString = uniString.replace(u"ö", "oe")
        uniString = uniString.replace(u"ß", "ss")
        uniString = uniString.replace(" ", "_")
        outString = uniString.encode("ASCII", "replace")      # conversion to ASCII for POV-Ray compatibility
        return outString.decode("utf-8") #return and redecode to unicode but with converted chars

    def uintColorToRGB(self, uintColor): #convert uint color to a rgb color
        Blue = (uintColor >> 8) & 255
        Green = (uintColor >> 16) & 255
        Red = (uintColor >> 24) & 255
        rgbString = "<{0:1.3f}, {1:1.3f}, {2:1.3f}>".format(Red / float(255), Green / float(255), Blue / float(255))
        return rgbString

    def delComments(self, code): #delete the comments in incContent
        #delete big comments
        while code.find("/*") is not -1:
            comStart = code.find("/*")
            comEnd = code.find("*/", comStart + 2)

            if comEnd is -1:
                App.Console.PrintError("Unable to delete all comments in the inc file!\nThere is an unclosed multi line comment.\n")
                return
            code = code[0:comStart] + code[comEnd + 2:]

        #delete little comments
        while code.find("//") is not -1:
            comStart = code.find("//")
            comEnd = code.find("\n", comStart + 2)

            if comEnd is -1:
                App.Console.PrintError("Unable to delete all comments in the inc file!\nThere is a misstake in a one line comment")
                return
            code = code[0:comStart] + code[comEnd:]
        return code


class GUI(QtGui.QDialog): #the pyside class for the dialog window
    def __init__(self):
        super(GUI, self).__init__()
        self.initUI()
        self.setDefaultValues()

    def initUI(self): #create the objects in the dialog window
        self.setWindowTitle("Export to POVray")

        #pov file selection
        self.pathLineEdit = QtGui.QLineEdit()
        self.pathLineEdit.setPlaceholderText("Path to .pov file")
        self.pathLineEdit.setFixedWidth(300)
        self.pathLineEdit.textChanged.connect(self.checkPath)

        self.openFileDialogButton = QtGui.QPushButton('Open pov File')
        self.openFileDialogButton.clicked.connect(self.openFileDialog)

        self.warnLabel = QtGui.QLabel("")
        self.warnLabel.setStyleSheet("QLabel { color : #ff0000; }")

        self.horizLayout1 = QtGui.QGridLayout()
        self.horizLayout1.addWidget(self.pathLineEdit, 0, 0)
        self.horizLayout1.addWidget(self.openFileDialogButton, 0, 1)
        self.horizLayout1.addWidget(self.warnLabel, 1, 0, 1, 2)

        self.pathGroup = QtGui.QGroupBox(".pov File Selection")
        self.pathGroup.setLayout(self.horizLayout1)

        #Width & Height of rendered image
        self.imageWidthLabel = QtGui.QLabel("Width")
        self.imageWidth = QtGui.QSpinBox()
        self.imageWidth.setMinimum(1)
        self.imageWidth.setMaximum(999999)
        self.imageWidth.setSuffix(" px")
        self.imageWidth.setValue(800)
        self.imageHeightLabel = QtGui.QLabel("Height")
        self.imageHeight = QtGui.QSpinBox()
        self.imageHeight.setMinimum(1)
        self.imageHeight.setMaximum(999999)
        self.imageHeight.setSuffix(" px")
        self.imageHeight.setValue(600)

        self.vertLayout1 = QtGui.QVBoxLayout()
        self.vertLayout1.addWidget(self.imageWidthLabel)
        self.vertLayout1.addWidget(self.imageWidth)
        self.vertLayout1.addWidget(self.imageHeightLabel)
        self.vertLayout1.addWidget(self.imageHeight)
        self.WHImageGroup = QtGui.QGroupBox("Width and Height of Image")
        self.WHImageGroup.setLayout(self.vertLayout1)

        #Options
        self.expBg = QtGui.QCheckBox("Export FreeCAD Background")
        self.expLight = QtGui.QCheckBox("Export FreeCAD light")

        self.repRot = QtGui.QCheckBox("Repair Rotation")
        self.expFcView = QtGui.QCheckBox("Export FreeCAD View")

        self.vertLayout2 = QtGui.QVBoxLayout()
        self.vertLayout2.addWidget(self.expBg)
        self.vertLayout2.addWidget(self.expLight)
        self.vertLayout2.addWidget(self.repRot)
        self.vertLayout2.addWidget(self.expFcView)
        self.optionGroups = QtGui.QGroupBox("Options")
        self.optionGroups.setLayout(self.vertLayout2)

        self.cancelButton = QtGui.QPushButton('Cancel')
        self.cancelButton.clicked.connect(self.onCancel)

        self.okButton = QtGui.QPushButton('OK')
        self.okButton.clicked.connect(self.onOk)
        self.okButton.setAutoDefault(True)

        self.mainLayout = QtGui.QVBoxLayout()
        self.mainLayout.addWidget(self.pathGroup)
        self.mainLayout.addWidget(self.WHImageGroup)
        self.mainLayout.addWidget(self.optionGroups)
        self.mainLayout.addWidget(self.cancelButton)
        self.mainLayout.addWidget(self.okButton)

        #create macro group
        self.macroGroup = QtGui.QGroupBox("")
        self.macroGroup.setLayout(self.mainLayout)

        #crate help group
        self.helpLabel = QtGui.QLabel("")

        #create tabs
        self.tabs = QtGui.QTabWidget(self)
        self.tabs.addTab(self.macroGroup, "Macro")
        self.tabs.addTab(self.helpLabel, "Help")

        self.wrapLayout = QtGui.QVBoxLayout()
        self.wrapLayout.addWidget(self.tabs)
        self.setLayout(self.wrapLayout)
        self.show()

    def setDefaultValues(self): #set the default values of the input objects
        defaultPath = "/home/"
        self.pathLineEdit.setText(defaultPath)

        #get saved input
        settings = QtCore.QSettings("Usb Hub, DerUhrmacher", "Export to POVray")
        settings.beginGroup("userInput")
        path = settings.value("path", self.pathLineEdit.text())
        width = int(settings.value("width", self.imageWidth.value()))
        height = int(settings.value("height", self.imageHeight.value()))
        expBg = settings.value("expBg", self.expBg.isChecked())
        expLight = settings.value("expLight", self.expLight.isChecked())
        repRot = settings.value("repRot", self.repRot.isChecked())
        expFcView = settings.value("expFcView", self.expFcView.isChecked())
        settings.endGroup()

        if expBg is None:
            self.expBg.setChecked(True)
        if expLight is None:
            self.expLight.setChecked(True)

        if path is not None:
            self.pathLineEdit.setText(path)
        if width is not None:
            self.imageWidth.setValue(width)
        if height is not None:
            self.imageHeight.setValue(height)
        if expBg is not None and (expBg == True or expBg == "true"):
            self.expBg.setCheckState(QtCore.Qt.CheckState(2))
        if expLight is not None and (expLight == True or expLight == "true"):
            self.expLight.setCheckState(QtCore.Qt.CheckState(2))
        if repRot is not None and (repRot == True or repRot == "true"):
            self.repRot.setCheckState(QtCore.Qt.CheckState(2))
        if expFcView is not None and (expFcView == True or expFcView == "true"):
            self.expFcView.setCheckState(QtCore.Qt.CheckState(2))

        helpText = """
        <style>
        div { margin: 15;}
        </style>
        <div>
        <h3>General</h3>
        <p>This macro exports solid CSG primitives to POV-Ray.<br>
        The resulting POV code is readable and intended for further editing.<br>
        You can add user defined material for each object in a <br>
        seperate .inc file that won't be overwritten.</p>
        <h3>Pov File Selection</h3>
        <p>Select the pov file by typing the path into the text field or choose a .pov file <br>
        with the 'Open pov File' button.<br>
        Be careful not to use spaces or special chars in pathname for POV-Ray compatibility.</p>
        <h3>Width and Height of the Image</h3>
        <p>Select the width and height in pixels of the image to be rendered with POV-Ray.</p>
        <h3>Options</h3>
        <h5>Export Background</h5>
        <p>Export the FreeCAD background</p>
        <h5>Export Light</h5>
        <p>Export the FreeCAD light</p>
        <h5>Repair Rotation</h5>
        <p>Use this option if objects in your scene appear in a wrong rotation.<br>
        This is a workaround for a FreeCAD bug.</p>
        <h5>Export FreeCAD View</h5>
        <p>Export the current FreeCAD view in the same size as the image rendered by POV-Ray<br></p>
        <p>For more information look in our <a href='https://gitlab.com/usbhub/exporttopovray/blob/master/doc/index.md'>Wiki</a></p>
        </div>"""
        self.helpLabel.setText(helpText)
        self.helpLabel.setOpenExternalLinks(True)

    def openFileDialog(self): #open the file dialog for the pov file
        defaultPath = self.pathLineEdit.text()

        fileName = QtGui.QFileDialog.getSaveFileName(None, 'Select path and name of the *.pov file', defaultPath, "PovRay Files (*.pov)")

        if fileName and fileName != (u'', u''):
            self.pathLineEdit.setText(str(fileName[0]))

    def checkPath(self, path): #check if the path to pov file is valid
        if path.find(" ") == -1 and isAscii(path) == True and path != "" and path[-4:] == ".pov":
            self.okButton.setEnabled(True)
            self.warnLabel.setText("")
        else:
            self.okButton.setEnabled(False)
            if path == "":
                self.warnLabel.setText("Please type a path or get one with clicking on 'Open pov File'")
            else:
                self.warnLabel.setText("Your path contains a space or a mutated vowel or is not a .pov file")

    def saveInput(self): #save the user inputs
        settings = QtCore.QSettings("Usb Hub, DerUhrmacher", "Export to POVray")
        settings.beginGroup("userInput")
        settings.setValue("path", self.pathLineEdit.text())
        settings.setValue("width", self.imageWidth.value())
        settings.setValue("height", self.imageHeight.value())
        settings.setValue("expBg", self.expBg.isChecked())
        settings.setValue("expLight", self.expLight.isChecked())
        settings.setValue("repRot", self.repRot.isChecked())
        settings.setValue("expFcView", self.expFcView.isChecked())
        settings.endGroup()

    def onCancel(self): #called if "Cancel" button is pressed
        self.result = "Canceled"
        self.close()
        App.Console.PrintMessage("\n\nCanceled\n\n")

    def onOk(self): #called if "OK" button is pressed
        self.result = "OK"
        self.close()
        self.saveInput()
        exporter = ExportToPovRay(self.pathLineEdit.text(), self.imageWidth.value(), self.imageHeight.value(), self.expBg.isChecked(), self.expLight.isChecked(), self.repRot.isChecked(), self.expFcView.isChecked())

def main(): #the main function
    try:
        viewPos = Gui.ActiveDocument.ActiveView.viewPosition()
    except:
        App.Console.PrintWarning("No document opened\n")
        return -1

    dialog = GUI()
    dialog.exec_()

main()
